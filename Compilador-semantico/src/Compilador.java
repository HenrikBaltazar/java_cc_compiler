/* Compilador.java */
/* Generated By:JavaCC: Do not edit this line. Compilador.java */
import java.util.List;
public class Compilador implements CompiladorConstants {
    StringBuilder errosSintaticos = new StringBuilder();
    int countParseError = 0;

    public String criaListaEsperados(int[][] sequenciaEsperada) {
        StringBuilder tokensEsperados = new StringBuilder();
        for (int[] sequencia : sequenciaEsperada) {
            for (int token : sequencia) {
                tokensEsperados.append(tokenImage[token]).append(" ");
            }
        }
        return tokensEsperados.toString().trim();
    }

    public static void main(String[] args) {
    }

    public String getParserErrors() {
        return errosSintaticos.toString();
    }

    public int getParseErrorCount() {
        return countParseError;
    }

    public Token estabilizaParser(Token tokenAtual) {
        Token auxToken = tokenAtual;
        System.out.println("Token atual: " + auxToken.image);
        while (true) {
            auxToken = getNextToken();
            if (auxToken != tokenAtual && auxToken.kind != 12 && auxToken.kind != 13 && auxToken.kind != 14
            && auxToken.kind != 15 && auxToken.kind != 16 && auxToken.kind != 17 && auxToken.kind != 18
            && auxToken.kind != 19 && auxToken.kind != 20 && auxToken.kind != 21 && auxToken.kind != 22 && auxToken.kind != 23 && auxToken.kind != 24 && auxToken.kind != 25
            && auxToken.kind != 26 && auxToken.kind != 27 && auxToken.kind != 28 && auxToken.kind != 31) tokenAtual = auxToken;
            else break;
        }
        System.out.println("Token estabilizado. Token encontrado: " + auxToken.image);
        System.out.println("Token anterior ao token encontrado: " + tokenAtual.image);
        return tokenAtual;
    }

// M2 / M3 - BNF / Tratamento de Erros Sintáticos / Ações Semânticas:
  final public void programa(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      jj_consume_token(MAKE);
      identificadorPrograma(analisadorSemantico);
      declaracaoConstVar(analisadorSemantico);
      listaComandos(analisadorSemantico);
      jj_consume_token(END);
      jj_consume_token(PONTO);
analisadorSemantico.reconhceFimPrograma();
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("programa: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'make <resto do programa> end .' \n");

        if (tokensEsperados.contains("make")) {
            errosSintaticos.append("Erro sint\u00e1tico: Programa deve come\u00e7ar com 'make'").append("\n");
        }else if (tokensEsperados.contains("end") || tokensEsperados.contains(".")){
            errosSintaticos.append("Erro sint\u00e1tico: Programa deve acabar com a palavra reservada 'end.'").append("\n\n");
        }
    }
}

  final public void identificadorPrograma(AnalisadorSemantico analisadorSemantico) throws ParseException {Token identificadorToken = new Token(52, "");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFICADOR:{
        identificadorToken = jj_consume_token(IDENTIFICADOR);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        ;
      }
analisadorSemantico.reconheceIdentificadorPrograma(identificadorToken);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("identificadorPrograma: " + tokensEsperados);
    }
}

  final public void declaracaoConstVar(AnalisadorSemantico analisadorSemantico) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CONST:
    case VAR:{
      constVar(analisadorSemantico);
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      ;
    }
}

  final public void constVar(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CONST:{
        declaracaoConst(analisadorSemantico);
        variaveis2(analisadorSemantico);
        break;
        }
      case VAR:{
        declaracaoVar(analisadorSemantico);
        constantes2(analisadorSemantico);
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("constVar: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'declaracaoConst() declaracaoVar() | declaracaoVar() declaracaoConst()' \n");

    }
}

  final public void declaracaoConst(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      jj_consume_token(CONST);
analisadorSemantico.reconhceConst();
      meioDeclaracaoConst(analisadorSemantico);
      jj_consume_token(END);
      jj_consume_token(PONTOVIRGULA);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("declaracaoConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<CONST> meioDeclaracaoConst() <END> <PONTOVIRGULA>]' \n");

        if (tokensEsperados.contains("const")){
            errosSintaticos.append("Erro sint\u00e1tico: Declara\u00e7\u00e3o de constantes deve come\u00e7ar com 'const'").append("\n\n");
        }else if (tokensEsperados.contains("end") || tokensEsperados.contains(";")) {
            errosSintaticos.append("Erro sint\u00e1tico: Declara\u00e7\u00e3o de constantes deve acabar com a palavra reservada 'end;'").append("\n\n");
        }
    }
}

  final public void declaracaoVar(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      jj_consume_token(VAR);
analisadorSemantico.reconheceVar();
      meioDeclaracaoVar(analisadorSemantico);
      jj_consume_token(END);
      jj_consume_token(PONTOVIRGULA);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("declaracaoVar: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<VAR> meioDeclaracaoVar() <END> <PONTOVIRGULA>]' \n");

        if (tokensEsperados.contains("var")){
            errosSintaticos.append("Erro sint\u00e1tico: Declara\u00e7\u00e3o de vari\u00e1veis deve come\u00e7ar com 'var'").append("\n\n");
        }else if (tokensEsperados.contains("end") || tokensEsperados.contains(";")) {
            errosSintaticos.append("Erro sint\u00e1tico: Declara\u00e7\u00e3o de vari\u00e1veis deve acabar com a palavra reservada 'end;'").append("\n\n");
        }
    }
}

  final public void meioDeclaracaoConst(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      tipos_const(analisadorSemantico);
      jj_consume_token(DOISPONTOS);
      listaIdentificadores(analisadorSemantico);
analisadorSemantico.reconheceFimDeclaracaoConstVar();
      jj_consume_token(IGUAL);
      valor(analisadorSemantico);
      jj_consume_token(PONTO);
      constantes1(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("meioDeclaracaoConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[tipos_const() <DOISPONTOS> listaIdentificadores() <IGUAL> valor() <PONTO> meioDeclaracaoConst()]' \n");

        if (tokensEsperados.contains(":") || tokensEsperados.contains(".") || tokensEsperados.contains("=")){
            errosSintaticos.append("Erro sint\u00e1tico: Declara\u00e7\u00e3o de constantes deve estar no formato: tipo ':' constante '=' valor '.'").append("\n\n");
        }
    }
}

  final public void constantes1(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CHAR:
      case INT:
      case REAL:{
        meioDeclaracaoConst(analisadorSemantico);
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        ;
      }
    } catch (ParseException e) {

    }
}

  final public void constantes2(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CONST:{
        declaracaoConst(analisadorSemantico);
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        ;
      }
    } catch (ParseException e) {

    }
}

  final public void meioDeclaracaoVar(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      tipos_var(analisadorSemantico);
      jj_consume_token(DOISPONTOS);
      listaIdentificadores(analisadorSemantico);
analisadorSemantico.reconheceFimDeclaracaoConstVar();
      jj_consume_token(PONTO);
      variaveis1(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("meioDeclaracaoVar: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[tipos_var() <DOISPONTOS> listaIdentificadores() <PONTO> meioDeclaracaoVar()]' \n");

        if (tokensEsperados.contains(":") || tokensEsperados.contains(".")){
            errosSintaticos.append("Erro sint\u00e1tico: Declara\u00e7\u00e3o de vari\u00e1veis deve estar no formato: tipo ':' vari\u00e1vel '.'").append("\n\n");
        }
    }
}

  final public void variaveis1(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOL:
      case CHAR:
      case INT:
      case REAL:{
        meioDeclaracaoVar(analisadorSemantico);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        ;
      }
    } catch (ParseException e) {

    }
}

  final public void variaveis2(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VAR:{
        declaracaoVar(analisadorSemantico);
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        ;
      }
    } catch (ParseException e) {

    }
}

  final public void atribuicao(AnalisadorSemantico analisadorSemantico) throws ParseException {Token identificadorToken;
    try {
      expressao(analisadorSemantico);
      jj_consume_token(ATRIBUICAO);
      identificadorToken = jj_consume_token(IDENTIFICADOR);
analisadorSemantico.reconheceIdentificadorAtribuicao(identificadorToken);
      jj_consume_token(PONTO);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("atribuicao: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'expressao(analisadorSemantico) <ATRIBUICAO> <IDENTIFICADOR> <PONTO>' \n");

        if (tokensEsperados.contains(".")){
            errosSintaticos.append("Erro sint\u00e1tico: Atribui\u00e7\u00e3o deve acabar com '.'").append("\n\n");
        } else if (tokensEsperados.contains("->") || tokensEsperados.contains("<IDENTIFICADOR>")){
            errosSintaticos.append("Erro sint\u00e1tico: Formato da Atribui\u00e7\u00e3o est\u00e1 incorreto.").append("\n\n");
        }
    }
}

  final public void entrada(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      jj_consume_token(GET);
analisadorSemantico.reconheceGet();
      jj_consume_token(PARENESQ);
      listaIdentificadores(analisadorSemantico);
      jj_consume_token(PARENDIR);
      jj_consume_token(PONTO);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Entrada: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<GET> <PARENESQ> listaIdentificadores() <PARENDIR> <PONTO>' \n");

        if (tokensEsperados.contains("(") || tokensEsperados.contains(")")){
            errosSintaticos.append("Erro sint\u00e1tico: identificadores devem estar entre '(' e ')'").append("\n\n");
        } else if (tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sint\u00e1tico: Entrada deve acabar com '.'").append("\n\n");
        } else if (tokensEsperados.contains("get")) {
            errosSintaticos.append("Erro sint\u00e1tico: Entrada deve come\u00e7ar com a palavra reservada 'get'").append("\n\n");
        }
    }
}

  final public void saida(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      jj_consume_token(PUT);
      jj_consume_token(PARENESQ);
      identconst(analisadorSemantico);
      jj_consume_token(PARENDIR);
      jj_consume_token(PONTO);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Sa\u00edda: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<PUT> <PARENESQ> identconst() <PARENDIR> <PONTO>' \n");

        if (tokensEsperados.contains("(") || tokensEsperados.contains(")")){
            errosSintaticos.append("Erro sint\u00e1tico: identificador de constantes ou vari\u00e1veis deve estar entre '(' e ')'").append("\n\n");
        } else if (tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sint\u00e1tico: Sa\u00edda deve acabar com '.'").append("\n\n");
        } else if (tokensEsperados.contains("put")) {
            errosSintaticos.append("Erro sint\u00e1tico: Sa\u00edda deve come\u00e7ar com a palavra reservada 'put'").append("\n\n");
        }
    }
}

  final public void listaComandos(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      comando(analisadorSemantico);
      restoListaComandos(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("listaComandos: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'comando() restoListaComandos()' \n");

    }
}

  final public void restoListaComandos(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FALSE:
      case GET:
      case IF:
      case PUT:
      case TRUE:
      case WHILE:
      case PARENESQ:
      case NAO:
      case IDENTIFICADOR:
      case CONSTANTE_NUMERICA_REAL:
      case CONSTANTE_NUMERICA_INTEIRA:
      case CONSTANTE_LITERAL:{
        comando(analisadorSemantico);
        restoListaComandos(analisadorSemantico);
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("restoListaComandos: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[comando() restoListaComandos()]' \n");

    }
}

  final public void comando(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FALSE:
      case TRUE:
      case PARENESQ:
      case NAO:
      case IDENTIFICADOR:
      case CONSTANTE_NUMERICA_REAL:
      case CONSTANTE_NUMERICA_INTEIRA:
      case CONSTANTE_LITERAL:{
        atribuicao(analisadorSemantico);
        break;
        }
      case GET:{
        entrada(analisadorSemantico);
        break;
        }
      case PUT:{
        saida(analisadorSemantico);
        break;
        }
      case IF:{
        selecao(analisadorSemantico);
        break;
        }
      case WHILE:{
        repeticao(analisadorSemantico);
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("comando: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'atribuicao() | entrada() | saida() | selecao() | repeticao()' \n");

        if (tokensEsperados.contains("const") || tokensEsperados.contains("get") || tokensEsperados.contains("put") || tokensEsperados.contains("while") || tokensEsperados.contains("if") || tokensEsperados.contains("var")) {
            errosSintaticos.append("Erro sint\u00e1tico: Comando n\u00e3o definido, utilize um dos comandos: const, get, put, while, if ou var").append("\n\n");
        }
    }
}

  final public void tipos_const(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:{
        jj_consume_token(INT);
analisadorSemantico.reconheceInt();
        break;
        }
      case REAL:{
        jj_consume_token(REAL);
analisadorSemantico.reconheceReal();
        break;
        }
      case CHAR:{
        jj_consume_token(CHAR);
analisadorSemantico.reconheceChar();
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("tipos_const: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<INT> | <REAL> | <CHAR>' \n");

        if (tokensEsperados.contains("int") || tokensEsperados.contains("real") || tokensEsperados.contains("char")) {
            errosSintaticos.append("Erro sint\u00e1tico: Constantes s\u00f3 podem ser do tipo INT, REAL ou CHAR").append("\n\n");
        }
    }
}

  final public void tipos_var(AnalisadorSemantico analisadorSemantico) throws ParseException {Token token;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT:{
        jj_consume_token(INT);
analisadorSemantico.reconheceInt();
        break;
        }
      case REAL:{
        jj_consume_token(REAL);
analisadorSemantico.reconheceReal();
        break;
        }
      case CHAR:{
        jj_consume_token(CHAR);
analisadorSemantico.reconheceChar();
        break;
        }
      case BOOL:{
        token = jj_consume_token(BOOL);
analisadorSemantico.reconheceBool(token.beginLine, token.beginColumn);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("tipos_var: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<INT> | <REAL> | <CHAR> | <BOOL>' \n");

        if (tokensEsperados.contains("int") || tokensEsperados.contains("real") || tokensEsperados.contains("char") || tokensEsperados.contains("bool")) {
            errosSintaticos.append("Erro sint\u00e1tico: Vari\u00e1veis s\u00f3 podem ser do tipo INT, REAL, CHAR ou BOOL").append("\n\n");
        }
    }
}

  final public void valor(AnalisadorSemantico analisadorSemantico) throws ParseException {Token valor1, valor2, valor3;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CONSTANTE_NUMERICA_INTEIRA:{
        valor1 = jj_consume_token(CONSTANTE_NUMERICA_INTEIRA);
analisadorSemantico.reconhceValorDeclaracaoConst(valor1);
        break;
        }
      case CONSTANTE_NUMERICA_REAL:{
        valor2 = jj_consume_token(CONSTANTE_NUMERICA_REAL);
analisadorSemantico.reconhceValorDeclaracaoConst(valor2);
        break;
        }
      case CONSTANTE_LITERAL:{
        valor3 = jj_consume_token(CONSTANTE_LITERAL);
analisadorSemantico.reconhceValorDeclaracaoConst(valor3);
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("valor: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<CONSTANTE_NUMERICA_INTEIRA> | <CONSTANTE_NUMERICA_REAL> | <CONSTANTE_LITERAL>' \n");

        if (tokensEsperados.contains("<CONSTANTE_NUMERICA_REAL>") || tokensEsperados.contains("<CONSTANTE_NUMERICA_INTEIRA>") || tokensEsperados.contains("<CONSTANTE_LITERAL>")) {
            errosSintaticos.append("Erro sint\u00e1tico: Valor deve ser Constante Num\u00e9rica Inteira OU Constante Num\u00e9rica Real OU Constante Literal").append("\n\n");
        }
    }
}

  final public void expressao(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      expressaoAritmeticaLogica(analisadorSemantico);
      expressaoLinha(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Express\u00e3o: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'expressaoAritmeticaLogica(analisadorSemantico) expressaoLinha()' \n");

    }
}

  final public void expressaoLinha(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IGUAL:
      case DIFERENTE:
      case MENOR:
      case MAIOR:
      case MENORIGUAL:
      case MAIORIGUAL:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IGUAL:{
          jj_consume_token(IGUAL);
          expressaoAritmeticaLogica(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoRelacionalIgual();
          break;
          }
        case DIFERENTE:{
          jj_consume_token(DIFERENTE);
          expressaoAritmeticaLogica(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoRelacionalDiferente();
          break;
          }
        case MENOR:{
          jj_consume_token(MENOR);
          expressaoAritmeticaLogica(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoRelacionalMenor();
          break;
          }
        case MAIOR:{
          jj_consume_token(MAIOR);
          expressaoAritmeticaLogica(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoRelacionalMaior();
          break;
          }
        case MENORIGUAL:{
          jj_consume_token(MENORIGUAL);
          expressaoAritmeticaLogica(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoRelacionalMenorIgual();
          break;
          }
        case MAIORIGUAL:{
          jj_consume_token(MAIORIGUAL);
          expressaoAritmeticaLogica(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoRelacionalMaiorIgual();
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("expressaoLinha: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        /*errosSintaticos.append("Formato esperado: '[<IGUAL> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("<DIFERENTE> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MENOR> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MAIOR> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MENORIGUAL> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MAIORIGUAL> expressaoAritmeticaLogica(analisadorSemantico)]' \n");*/

        if (tokensEsperados.contains("=") || tokensEsperados.contains("<>") || tokensEsperados.contains("<") || tokensEsperados.contains(">") || tokensEsperados.contains(">=") || tokensEsperados.contains("<=")) {
            errosSintaticos.append("Erro sint\u00e1tico: As express\u00f5es devem conter um dos seguintes s\u00edmbolos: '=', '<>', '<', '>', '<=', '>=' ").append("\n\n");
        }
    }
}

  final public void expressaoAritmeticaLogica(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      termo2(analisadorSemantico);
      menorPrioridade(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("expressaoAritmeticaLogica: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'termo2(analisadorSemantico) menorPrioridade(analisadorSemantico)' \n");

    }
}

  final public void menorPrioridade(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MAIS:
      case MENOS:
      case OU:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MAIS:{
          jj_consume_token(MAIS);
          termo2(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoAritmeticaAdicao();
          menorPrioridade(analisadorSemantico);
          break;
          }
        case MENOS:{
          jj_consume_token(MENOS);
          termo2(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoAritmeticaSubtracao();
          menorPrioridade(analisadorSemantico);
          break;
          }
        case OU:{
          jj_consume_token(OU);
          termo2(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoLogicaOu();
          menorPrioridade(analisadorSemantico);
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("menorPrioridade: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        /*errosSintaticos.append("Formato esperado: '[<MAIS> termo2(analisadorSemantico) menorPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<MENOS> termo2(analisadorSemantico) menorPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<OU> termo2(analisadorSemantico) menorPrioridade(analisadorSemantico)]' \n");*/

        if (tokensEsperados.contains("+") || tokensEsperados.contains("-") || tokensEsperados.contains("|")) {
            errosSintaticos.append("Erro sint\u00e1tico: Express\u00e3o deve conter um dos seguintes s\u00edmbolos: '+', '-', '|' ").append("\n\n");
        }
    }
}

  final public void termo2(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      termo1(analisadorSemantico);
      mediaPrioridade(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("TERMO2: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico)' \n");

    }
}

  final public void mediaPrioridade(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACAO:
      case DIVISAO:
      case DIVISAOINTEIRA:
      case RESTODIVISAOINTEIRA:
      case E:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MULTIPLICACAO:{
          jj_consume_token(MULTIPLICACAO);
          termo1(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoAritmeticaMultiplicacao();
          mediaPrioridade(analisadorSemantico);
          break;
          }
        case DIVISAO:{
          jj_consume_token(DIVISAO);
          termo1(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoAritmeticaDivisaoReal();
          mediaPrioridade(analisadorSemantico);
          break;
          }
        case DIVISAOINTEIRA:{
          jj_consume_token(DIVISAOINTEIRA);
          termo1(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoAritmeticaDivisaoInteira();
          mediaPrioridade(analisadorSemantico);
          break;
          }
        case RESTODIVISAOINTEIRA:{
          jj_consume_token(RESTODIVISAOINTEIRA);
          termo1(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoAritmeticaRestoDivisaoInteira();
          mediaPrioridade(analisadorSemantico);
          break;
          }
        case E:{
          jj_consume_token(E);
          termo1(analisadorSemantico);
analisadorSemantico.reconheceOperacaoLogicaE();
          mediaPrioridade(analisadorSemantico);
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("MediaPrioridade: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        /*errosSintaticos.append("Formato esperado: '[<MULTIPLICACAO> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<DIVISAO> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<DIVISAOINTEIRA> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<RESTODIVISAOINTEIRA> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<E> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico)]'");*/

        if (tokensEsperados.contains("*") || tokensEsperados.contains("/") || tokensEsperados.contains("%") || tokensEsperados.contains("%%") || tokensEsperados.contains("&")) {
            errosSintaticos.append("Erro sint\u00e1tico: Express\u00e3o deve conter um dos seguintes s\u00edmbolos: '*', '/', '%', '%%', '&' ").append("\n\n");
        }
    }
}

  final public void termo1(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      elemento(analisadorSemantico);
      maiorPrioridade(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("TERMO1: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'elemento() maiorPrioridade()' \n");

    }
}

  final public void maiorPrioridade(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case POTENCIA:{
        jj_consume_token(POTENCIA);
        elemento(analisadorSemantico);
analisadorSemantico.reconhecerOperacaoAritmeticaPotenciacao();
        maiorPrioridade(analisadorSemantico);
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("maiorPrioridade: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        // errosSintaticos.append("Formato esperado: '[<POTENCIA> elemento() maiorPrioridade()]' \n");

        if (tokensEsperados.contains("**")) {
            errosSintaticos.append("Erro sint\u00e1tico: Express\u00e3o deve conter o s\u00edmbolo: '**' ").append("\n\n");
        }
    }
}

  final public void elemento(AnalisadorSemantico analisadorSemantico) throws ParseException {Token identificador, constInt, constFloat, constLit;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFICADOR:{
        identificador = jj_consume_token(IDENTIFICADOR);
analisadorSemantico.reconhecerIdentificadorSaidaOuExpressao(identificador);
        break;
        }
      case CONSTANTE_NUMERICA_INTEIRA:{
        constInt = jj_consume_token(CONSTANTE_NUMERICA_INTEIRA);
analisadorSemantico.reconhecerConstanteInteira(constInt);
        break;
        }
      case CONSTANTE_NUMERICA_REAL:{
        constFloat = jj_consume_token(CONSTANTE_NUMERICA_REAL);
analisadorSemantico.reconhecerConstanteReal(constFloat);
        break;
        }
      case CONSTANTE_LITERAL:{
        constLit = jj_consume_token(CONSTANTE_LITERAL);
analisadorSemantico.reconhecerConstanteLiteral(constLit);
        break;
        }
      case TRUE:{
        jj_consume_token(TRUE);
analisadorSemantico.reconhecerConstanteLogicaVerdadeiro();
        break;
        }
      case FALSE:{
        jj_consume_token(FALSE);
analisadorSemantico.reconhecerConstanteLogicaFalso();
        break;
        }
      case PARENESQ:{
        jj_consume_token(PARENESQ);
        expressao(analisadorSemantico);
        jj_consume_token(PARENDIR);
        break;
        }
      case NAO:{
        jj_consume_token(NAO);
        jj_consume_token(PARENESQ);
        expressao(analisadorSemantico);
        jj_consume_token(PARENDIR);
analisadorSemantico.reconheceOperacaoLogicaNao();
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Elemento: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<IDENTIFICADOR> | <CONSTANTE_NUMERICA_INTEIRA> | <CONSTANTE_NUMERICA_REAL> | <CONSTANTE_LITERAL> | <TRUE> | <FALSE> | <PARENESQ> expressao(analisadorSemantico) <PARENDIR> | <NAO> <PARENESQ> expressao(analisadorSemantico) <PARENDIR>' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>") || tokensEsperados.contains("<CONSTANTE_NUMERICA_INTEIRA>") || tokensEsperados.contains("<CONSTANTE_NUMERICA_REAL") || tokensEsperados.contains("<CONSTANTE_LITERAL") || tokensEsperados.contains("true") || tokensEsperados.contains("false")) {
            errosSintaticos.append("Erro sint\u00e1tico: Elemento deve ser um: Identificador OU Constante Num\u00e9rica Inteira OU Constante Num\u00e9rica Real OU Constante Literal OU 'true' OU 'false'").append("\n\n");
        } else if (tokensEsperados.contains("(") || tokensEsperados.contains(")")) {
            errosSintaticos.append("Erro sint\u00e1tico: Elemento deve estar entre '(' e ')'").append("\n\n");
        } else if (tokensEsperados.contains("!") || tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sint\u00e1tico: Elemento deve estar entre '!(' e ')'").append("\n\n");
        }
    }
}

  final public void listaIdentificadores(AnalisadorSemantico analisadorSemantico) throws ParseException {Token identificadorToken;
    try {
      identificadorToken = jj_consume_token(IDENTIFICADOR);
analisadorSemantico.reconheceIdentificador(identificadorToken);
      restoLista(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("ListaIdentificadores: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<IDENTIFICADOR> restoLista()' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>")) {
            errosSintaticos.append("Erro sint\u00e1tico: Comando deve conter pelo menos um identificador").append("\n\n");
        }
    }
}

  final public void restoLista(AnalisadorSemantico analisadorSemantico) throws ParseException {Token identificadorToken;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VIRGULA:{
        jj_consume_token(VIRGULA);
        identificadorToken = jj_consume_token(IDENTIFICADOR);
analisadorSemantico.reconheceIdentificador(identificadorToken);
        restoLista(analisadorSemantico);
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("restoLista: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<VIRGULA> <IDENTIFICADOR> restoLista()]' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>")) {
            errosSintaticos.append("Erro sint\u00e1tico: Comando deve conter pelo menos um identificador").append("\n\n");
        } else if (tokensEsperados.contains(",")) {
            errosSintaticos.append("Erro sint\u00e1tico: Identificadores devem ser separados por ','").append("\n\n");
        }
    }
}

  final public void repeticao(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      jj_consume_token(WHILE);
analisadorSemantico.reconhecerInicioWhile();
      expressao(analisadorSemantico);
analisadorSemantico.reconhecerExpressaoComandoRepeticao();
      jj_consume_token(DO);
      listaComandos(analisadorSemantico);
      jj_consume_token(END);
      jj_consume_token(PONTO);
analisadorSemantico.reconhecerFimComandoRepeticao();
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Repeti\u00e7\u00e3o: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<WHILE> expressao(analisadorSemantico) <DO> listaComandos() <END> <PONTO>' \n");

        if (tokensEsperados.contains("while")){
            errosSintaticos.append("Erro sint\u00e1tico: Repeti\u00e7\u00e3o deve come\u00e7ar com a palavra reservada 'while'").append("\n\n");
        } else if (tokensEsperados.contains("do")) {
            errosSintaticos.append("Erro sint\u00e1tico: Repeti\u00e7\u00e3o deve conter a palavra reservada 'do'").append("\n\n");
        } else if (tokensEsperados.contains("end") || tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sint\u00e1tico: Repeti\u00e7\u00e3o deve acabar com a palavra reservada 'end.'").append("\n\n");
        }
    }
}

  final public void selecao(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      jj_consume_token(IF);
      expressao(analisadorSemantico);
analisadorSemantico.reconhecerExpressaoComandoSelecao();
      jj_consume_token(THEN);
      listaComandos(analisadorSemantico);
      senao(analisadorSemantico);
      jj_consume_token(END);
      jj_consume_token(PONTO);
analisadorSemantico.reconhecerFimComandoSelecao();
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Sele\u00e7\u00e3o: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<IF> expressao(analisadorSemantico) <THEN> listaComandos() senao() <END> <PONTO>' \n");

        if (tokensEsperados.contains("if")){
            errosSintaticos.append("Erro sint\u00e1tico: Sele\u00e7\u00e3o deve come\u00e7ar com a palavra reservada 'if'").append("\n\n");
        } else if (tokensEsperados.contains("then")) {
            errosSintaticos.append("Erro sint\u00e1tico: Sele\u00e7\u00e3o deve conter a palavra reservada 'then'").append("\n\n");
        } else if (tokensEsperados.contains("end") || tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sint\u00e1tico: Sele\u00e7\u00e3o deve acabar com a palavra reservada 'end.'").append("\n\n");
        }
    }
}

  final public void senao(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSE:{
        jj_consume_token(ELSE);
analisadorSemantico.reconhecerClausulaSenao();
        listaComandos(analisadorSemantico);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Sen\u00e3o: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<ELSE> listaComandos()]' \n");

        if (tokensEsperados.contains("else")) {
            errosSintaticos.append("Erro sint\u00e1tico: Sele\u00e7\u00e3o deve cont\u00e9r a palavra reservada 'else'").append("\n\n");
        }
    }
}

  final public void identconst(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      identconstAux(analisadorSemantico);
analisadorSemantico.reconheceMensagemSaidaDados();
      restoIdentconst(analisadorSemantico);
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("identConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'identconstAux() restoIdentconst()' \n");

    }
}

  final public void restoIdentconst(AnalisadorSemantico analisadorSemantico) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VIRGULA:{
        jj_consume_token(VIRGULA);
        identconst(analisadorSemantico);
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        ;
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("restoIdentConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<VIRGULA> identconstAux() restoIdentconst()]' \n");

        if (tokensEsperados.contains(",")) {
            errosSintaticos.append("Erro sint\u00e1tico: Comando deve conter ','").append("\n\n");
        }
    }
}

  final public void identconstAux(AnalisadorSemantico analisadorSemantico) throws ParseException {Token identificador, constInt, constFloat, constLit;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFICADOR:{
        identificador = jj_consume_token(IDENTIFICADOR);
analisadorSemantico.reconhecerIdentificadorSaidaOuExpressao(identificador);
        break;
        }
      case CONSTANTE_NUMERICA_INTEIRA:{
        constInt = jj_consume_token(CONSTANTE_NUMERICA_INTEIRA);
analisadorSemantico.reconhecerConstanteInteira(constInt);
        break;
        }
      case CONSTANTE_NUMERICA_REAL:{
        constFloat = jj_consume_token(CONSTANTE_NUMERICA_REAL);
analisadorSemantico.reconhecerConstanteReal(constFloat);
        break;
        }
      case CONSTANTE_LITERAL:{
        constLit = jj_consume_token(CONSTANTE_LITERAL);
analisadorSemantico.reconhecerConstanteLiteral(constLit);
        break;
        }
      case TRUE:{
        jj_consume_token(TRUE);
analisadorSemantico.reconhecerConstanteLogicaVerdadeiro();
        break;
        }
      case FALSE:{
        jj_consume_token(FALSE);
analisadorSemantico.reconhecerConstanteLogicaFalso();
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("identConstAux: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'valor() | <IDENTIFICADOR>' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>")) {
            errosSintaticos.append("Erro sint\u00e1tico: Esperava Identificador ou constante").append("\n\n");
        }
    }
}

  /** Generated Token Manager. */
  public CompiladorTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[24];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x4004000,0x4004000,0x902000,0x4000,0x903000,0x4000000,0xa4e0000,0xa4e0000,0x902000,0x903000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2020000,0x40000000,0x8000,0x40000000,0x2020000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0xf80008,0xf80008,0x0,0x0,0xe00000,0x1f002,0x1f002,0x40060,0x40060,0x20d80,0x20d80,0x200,0xf80008,0x0,0x0,0x0,0xf00000,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	}

  /** Constructor with InputStream. */
  public Compilador(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Compilador(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new CompiladorTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Compilador(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new CompiladorTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new CompiladorTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Compilador(CompiladorTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CompiladorTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[69];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 24; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 69; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
