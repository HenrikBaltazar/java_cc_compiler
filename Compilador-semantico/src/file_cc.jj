options {
    STATIC = false;
}

// M2 - Métodos Analisador sintático
PARSER_BEGIN(Compilador)
import java.util.List;
public class Compilador {
    StringBuilder errosSintaticos = new StringBuilder();
    int countParseError = 0;

    public String criaListaEsperados(int[][] sequenciaEsperada) {
        StringBuilder tokensEsperados = new StringBuilder();
        for (int[] sequencia : sequenciaEsperada) {
            for (int token : sequencia) {
                tokensEsperados.append(tokenImage[token]).append(" ");
            }
        }
        return tokensEsperados.toString().trim();
    }

    public static void main(String[] args) {
    }

    public String getParserErrors() {
        return errosSintaticos.toString();
    }

    public int getParseErrorCount() {
        return countParseError;
    }

    public Token estabilizaParser(Token tokenAtual) {
        Token auxToken = tokenAtual;
        System.out.println("Token atual: " + auxToken.image);
        while (true) {
            auxToken = getNextToken();
            if (auxToken != tokenAtual && auxToken.kind != 12 && auxToken.kind != 13 && auxToken.kind != 14
            && auxToken.kind != 15 && auxToken.kind != 16 && auxToken.kind != 17 && auxToken.kind != 18
            && auxToken.kind != 19 && auxToken.kind != 20 && auxToken.kind != 21 && auxToken.kind != 22 && auxToken.kind != 23 && auxToken.kind != 24 && auxToken.kind != 25
            && auxToken.kind != 26 && auxToken.kind != 27 && auxToken.kind != 28 && auxToken.kind != 31) tokenAtual = auxToken;
            else break;
        }
        System.out.println("Token estabilizado. Token encontrado: " + auxToken.image);
        System.out.println("Token anterior ao token encontrado: " + tokenAtual.image);
        return tokenAtual;
    }
}

PARSER_END(Compilador)

// M1 - Métodos Analisador Léxico
TOKEN_MGR_DECLS : {
    int countLexError = 0;
    StringBuilder errosLexicos = new StringBuilder();

    public int multilineCommentStartLine = -1;
    public int multilineCommentStartColumn = -1;

    public int getLexErrorCount() {
        return countLexError;
    }

    public String getErrosLexicos() {
        return errosLexicos.toString();
    }

    public void checkUnclosedMultilineComment() {
        if (curLexState == CompiladorConstants.MULTILINE_COMMENT) {
            errosLexicos.append("Erro léxico: Comentário de bloco não foi fechado. ")
                .append("Comentário aberto na linha ").append(multilineCommentStartLine)
                .append(", coluna ").append(multilineCommentStartColumn).append(".\n");
            System.out.println("entrou aqui, erro comentário de bloco. Erros léxicos: " + countLexError++);
        }
    }

    public boolean isTokenIgnored(Token token) {
        return "/*".equals(token.image);
    }
}

// M1 - Símbolos que vão ser ignorados pelo getNextToken
SKIP : {
    " " | "\t" | "\n" | "\r" | "\f" |    // Ignora espaços e quebras de linha
    "//" : SINGLELINE_COMMENT |          // Ignora comentários de linha
    < INICIO : "/*" > {
        multilineCommentStartLine = input_stream.getBeginLine();
        multilineCommentStartColumn = input_stream.getBeginColumn();
        SwitchTo(MULTILINE_COMMENT);
    }  // Entra no estado MULTILINE_COMMENT quando encontra "/*"
}

< MULTILINE_COMMENT > SKIP : {
    < ~[] > |                    // Ignora todos os caracteres
    "*/" { SwitchTo(DEFAULT); }  // Sai do estado MULTILINE_COMMENT quando encontra "*/"
}

< SINGLELINE_COMMENT > SKIP : {
    < ["\n", "\r"] > { SwitchTo(DEFAULT); } |
    < ~[] >
}

// M1 - Palavras reservadas
TOKEN [IGNORE_CASE]: {
    < BOOL: "bool" > |
    < CHAR: "char" > |
    < CONST: "const" > |
    < ELSE: "else" > |
    < END: "end"> |
    < FALSE: "false"> |
    < GET: "get"> |
    < IF: "if" > |
    < INT: "int" > |
    < MAKE: "make" > |
    < PUT: "put" > |
    < REAL: "real" > |
    < THEN: "then" > |
    < TRUE: "true" > |
    < VAR: "var" > |
    < WHILE: "while" > |
    < DO: "do" >
}

// M1 - Símbolos especiais
TOKEN : {
    < PONTO: "." > |
    < VIRGULA: "," > |
    < PONTOVIRGULA: ";" > |
    < DOISPONTOS: ":" > |
    < IGUAL: "=" > |
    < ATRIBUICAO: "->" > |
    < PARENESQ: "(" > |
    < PARENDIR: ")" > |
    < MAIS: "+" > |
    < MENOS: "-" > |
    < MULTIPLICACAO: "*" > |
    < DIVISAO: "/" > |
    < POTENCIA: "**" > |
    < DIVISAOINTEIRA: "%" > |
    < RESTODIVISAOINTEIRA: "%%" > |
    < DIFERENTE: "<>" > |
    < MENOR: "<" > |
    < MAIOR: ">" > |
    < MENORIGUAL: "<=" > |
    < MAIORIGUAL: ">=" > |
    < E: "&" > |
    < OU: "|" > |
    < NAO: "!" >
}

// M1 - Gramática das Constantes e do Identificador
TOKEN : {
    < IDENTIFICADOR: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "_"] | (["0"-"9"] (["a"-"z", "A"-"Z", "_"])+))* > |
    < CONSTANTE_NUMERICA_REAL:(["0"-"9"]) (["0"-"9"])? (["0"-"9"])? (["0"-"9"])? "." (["0"-"9"]) (["0"-"9"])? > |
    < CONSTANTE_NUMERICA_INTEIRA:(["0"-"9"]) (["0"-"9"])? (["0"-"9"])? > |
    < CONSTANTE_LITERAL: ("\"" (~["\"", "\n"])* "\"") | ("'" (~["'", "\n"]) * "'") >
}

// M1 - Tratamento de erros léxicos
SPECIAL_TOKEN : {
    <INVALID_LEXICAL:(~["a"-"z", "A"-"Z", "0"-"9", ".", ",", ";", ":", "=", "(", ")", "+", "-", "*", "/", "%","<", ">", "&", "|", "!", " ", "\t", "\n", "\r", "\f"])+> {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Invalid string found: " + image);
        errosLexicos.append("Erro léxico: Símbolo desconhecido -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_IDENTIFIER: (["0"-"9"])|(["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "_", "0"-"9"])* (["0"-"9"]["0"-"9"])+ (["a"-"z", "A"-"Z", "_", "0"-"9"])*|(["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "_", "0"-"9"])* ["0"-"9"]> {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Identificador inválido: " + image);
        errosLexicos.append("Erro léxico: Identificador inválido -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
   }
|
    <INVALID_LITERAL: ("\"" (~["\"", "\n"])* "\"" (["a"-"z", "A"-"Z", "0"-"9", "\"", "\'"])*) | ("'" (~["'", "\n"]) * "'" (["a"-"z", "A"-"Z","0"-"9", "\"", "\'"])*) > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Constante literal inválida: " + image);
        System.out.println("literal 1");
        errosLexicos.append("Erro léxico: Constante literal inválida -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
   }
|
    /*<INVALID_LITERAL_2: (~["\'", "\n", "\r", "\t", " "]) * "\'" (["a"-"z", "A"-"Z", "0"-"9", "\"", "\'"])*> {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Constante literal inválida: não começa com '\'' e termina com '\'': " + image);
        System.out.println("literal 2");
        errosLexicos.append("Erro léxico: Constante literal inválida -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|*/
    /*<INVALID_LITERAL_3: (~["\"", "\n", "\r", "\t", " "]) * "\"" (["a"-"z", "A"-"Z", "0"-"9", "\"", "\'"])*> {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Constante literal inválida: não começa com '\'' e termina com '\'': " + image);
        System.out.println("literal 3");
        errosLexicos.append("Erro léxico: Constante literal inválida -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|*/
    <INVALID_LITERAL_UNTERMINATED_DQUOTE: "\"" (~["\"", "\n", "\r", "\t"]) * (~["\""]) > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Constante literal inválida: começa com '\"' e não termina com '\"': " + image);
        errosLexicos.append("Erro léxico: Constante literal inválida -> começa com '\"' e não termina com '\"' -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_LITERAL_UNTERMINATED_SQUOTE: "'" (~["'", "\n", "\r", "\t"]) * (~["'"]) > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Constante literal inválida: começa com '\'' e não termina com '\'' : " + image);
        errosLexicos.append("Erro léxico: Constante literal inválida -> começa com '\'' e não termina com '\'' -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_LITERAL_MISMATCH_DQUOTE_SQUOTE: "\"" (~["\"", "\n", "\r", "\t"]) * "'" > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Constante literal inválida: começa com '\"' e termina com '\'' : " + image);
        errosLexicos.append("Erro léxico: Constante literal inválida -> começa com '\"' e termina com ' -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_LITERAL_MISMATCH_SQUOTE_DQUOTE: "'" (~["'", "\n", "\r", "\t"]) * "\"" > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Constante literal inválida: começa com '\'' e termina com '\"' : " + image);
        errosLexicos.append("Erro léxico: Constante literal inválida -> começa com '\'' e termina com '\"' -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
   <INVALID_REAL: (~["0"-"9", " ", ",", ";", ":", "=", "(", ")", "+", "-", "*", "/", "%","<", ">", "&", "|", "!","\t", "\n", "\r"])* (["0"-"9"]) (["0"-"9"])? (["0"-"9"])? (["0"-"9"])? (~["0"-"9", ".", " ", "\t", "\n", "\r"])* "."(~["0"-"9", " ", "\t", "\n", "\r", "."])* (["0"-"9"]) (["0"-"9"])?(~["0"-"9", " ", ",", ";", ":", "=", "(", ")", "+", "-", "*", "/", "%","<", ">", "&", "|", "!", "\t", "\n", "\r", "."])* > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Número real inválido 1: " + image);
        errosLexicos.append("Erro léxico: Constante real inválida -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
   }
|
    <INVALID_REAL_NUMBER_SIZE: (["0"-"9"])(["0"-"9"])(["0"-"9"])(["0"-"9"])(["0"-"9"])+ "." (["0"-"9"])?(["0"-"9"])? > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Número real inválido 2: " + image);
        errosLexicos.append("Erro léxico: Constante real deve ter no máximo 4 dígitos antes do ponto decimal e até 2 dígitos após o ponto -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_REAL_NUMBER_DIGITS_AFTER: (["0"-"9"])(["0"-"9"])?(["0"-"9"])?(["0"-"9"])? "." (["0"-"9"])(["0"-"9"])(["0"-"9"])+ > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Número real inválido 3: " + image);
        errosLexicos.append("Erro léxico: Constante real deve ter no máximo 4 dígitos antes do ponto decimal e até 2 dígitos após o ponto -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_REAL_NUMBER_WITH_LETTERS: (<CONSTANTE_NUMERICA_REAL> | <INVALID_REAL_NUMBER_SIZE> | <INVALID_REAL_NUMBER_DIGITS_AFTER>) (["a"-"z", "A"-"Z"])+ > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Número real inválido (contém letras): " + image);
        errosLexicos.append("Erro léxico: Constante real não deve conter letras -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_INTEGER: (["0"-"9"]) (~["0"-"9", " ", ",", ";", ":", "=", "(", ")", "+", "-", "*", "/", "%","<", ">", "&", "|", "!","\t", "\n", "\r", "."])* (["0"-"9"])? (~["0"-"9", " ", ",", ";", ":", "=", "(", ")", "+", "-", "*", "/", "%","<", ">", "&", "|", "!","\t", "\n", "\r", "."])* (["0"-"9"])? (~["0"-"9", " ", ",", ";", ":", "=", "(", ")", "+", "-", "*", "/", "%","<", ">", "&", "|", "!","\t", "\n", "\r", "."])* > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Número inteiro inválido: " + image);
        errosLexicos.append("Erro léxico: Constante inteira inválida -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
|
    <INVALID_INTEGER_SIZE: (["0"-"9"])(["0"-"9"])(["0"-"9"])(["0"-"9"])+ > {
        // System.err.println("Linha: " + input_stream.getEndLine() + ", Coluna: " + input_stream.getEndColumn() + " - Número inteiro inválido: " + image);
        errosLexicos.append("Erro léxico: Constante inteira deve ter o tamanho máximo 3 -> Token: ").append(image).append(", Linha: ").append(input_stream.getEndLine()).append(", Coluna: ").append(input_stream.getEndColumn()).append("\n");
        countLexError++;
    }
}

// M2 / M3 - BNF / Tratamento de Erros Sintáticos / Ações Semânticas:
void programa(AnalisadorSemantico analisadorSemantico): {} {
    try {
        <MAKE> identificadorPrograma(analisadorSemantico) declaracaoConstVar(analisadorSemantico) listaComandos(analisadorSemantico) <END> <PONTO> {
        analisadorSemantico.reconhceFimPrograma();
        }
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("programa: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'make <resto do programa> end .' \n");

        if (tokensEsperados.contains("make")) {
            errosSintaticos.append("Erro sintático: Programa deve começar com 'make'").append("\n");
        }else if (tokensEsperados.contains("end") || tokensEsperados.contains(".")){
            errosSintaticos.append("Erro sintático: Programa deve acabar com a palavra reservada 'end.'").append("\n\n");
        }
    }
}

void identificadorPrograma(AnalisadorSemantico analisadorSemantico): {Token identificadorToken = new Token(52, "");} {
    try {
        [identificadorToken = <IDENTIFICADOR>]
        {
            analisadorSemantico.reconheceIdentificadorPrograma(identificadorToken);
        }
    } catch (ParseException e ) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("identificadorPrograma: " + tokensEsperados);
    }
}

void declaracaoConstVar(AnalisadorSemantico analisadorSemantico): {} {
    [constVar(analisadorSemantico)]
}

void constVar(AnalisadorSemantico analisadorSemantico): {} {
    try {
        declaracaoConst(analisadorSemantico) variaveis2(analisadorSemantico) | declaracaoVar(analisadorSemantico) constantes2(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("constVar: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'declaracaoConst() declaracaoVar() | declaracaoVar() declaracaoConst()' \n");
    }
}

void declaracaoConst(AnalisadorSemantico analisadorSemantico): {} {
    try {
        <CONST> {
        analisadorSemantico.reconhceConst();
        } meioDeclaracaoConst(analisadorSemantico) <END> <PONTOVIRGULA>
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("declaracaoConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<CONST> meioDeclaracaoConst() <END> <PONTOVIRGULA>]' \n");

        if (tokensEsperados.contains("const")){
            errosSintaticos.append("Erro sintático: Declaração de constantes deve começar com 'const'").append("\n\n");
        }else if (tokensEsperados.contains("end") || tokensEsperados.contains(";")) {
            errosSintaticos.append("Erro sintático: Declaração de constantes deve acabar com a palavra reservada 'end;'").append("\n\n");
        }
    }
}

void declaracaoVar(AnalisadorSemantico analisadorSemantico): {} {
    try {
        <VAR> {analisadorSemantico.reconheceVar();} meioDeclaracaoVar(analisadorSemantico) <END> <PONTOVIRGULA>
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("declaracaoVar: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<VAR> meioDeclaracaoVar() <END> <PONTOVIRGULA>]' \n");

        if (tokensEsperados.contains("var")){
            errosSintaticos.append("Erro sintático: Declaração de variáveis deve começar com 'var'").append("\n\n");
        }else if (tokensEsperados.contains("end") || tokensEsperados.contains(";")) {
            errosSintaticos.append("Erro sintático: Declaração de variáveis deve acabar com a palavra reservada 'end;'").append("\n\n");
        }
    }
}

void meioDeclaracaoConst(AnalisadorSemantico analisadorSemantico): {} {
    try {
        tipos_const(analisadorSemantico) <DOISPONTOS> listaIdentificadores(analisadorSemantico) {
        analisadorSemantico.reconheceFimDeclaracaoConstVar();
        } <IGUAL> valor(analisadorSemantico) <PONTO> constantes1(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("meioDeclaracaoConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[tipos_const() <DOISPONTOS> listaIdentificadores() <IGUAL> valor() <PONTO> meioDeclaracaoConst()]' \n");

        if (tokensEsperados.contains(":") || tokensEsperados.contains(".") || tokensEsperados.contains("=")){
            errosSintaticos.append("Erro sintático: Declaração de constantes deve estar no formato: tipo ':' constante '=' valor '.'").append("\n\n");
        }
    }
}

void constantes1(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [meioDeclaracaoConst(analisadorSemantico)]
    }
    catch (ParseException e) {

    }
}

void constantes2(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [declaracaoConst(analisadorSemantico)]
    }
    catch (ParseException e) {

    }
}

void meioDeclaracaoVar(AnalisadorSemantico analisadorSemantico): {} {
    try {
        tipos_var(analisadorSemantico) <DOISPONTOS> listaIdentificadores(analisadorSemantico) {analisadorSemantico.reconheceFimDeclaracaoConstVar();} <PONTO> variaveis1(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("meioDeclaracaoVar: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[tipos_var() <DOISPONTOS> listaIdentificadores() <PONTO> meioDeclaracaoVar()]' \n");

        if (tokensEsperados.contains(":") || tokensEsperados.contains(".")){
            errosSintaticos.append("Erro sintático: Declaração de variáveis deve estar no formato: tipo ':' variável '.'").append("\n\n");
        }
    }
}

void variaveis1(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [meioDeclaracaoVar(analisadorSemantico)]
    }
    catch (ParseException e) {

    }
}

void variaveis2(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [declaracaoVar(analisadorSemantico)]
    }
    catch (ParseException e) {

    }
}

void atribuicao(AnalisadorSemantico analisadorSemantico): {Token identificadorToken;} {
    try {
        expressao(analisadorSemantico) <ATRIBUICAO> identificadorToken = <IDENTIFICADOR> {analisadorSemantico.reconheceIdentificadorAtribuicao(identificadorToken);} <PONTO>
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("atribuicao: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'expressao(analisadorSemantico) <ATRIBUICAO> <IDENTIFICADOR> <PONTO>' \n");

        if (tokensEsperados.contains(".")){
            errosSintaticos.append("Erro sintático: Atribuição deve acabar com '.'").append("\n\n");
        } else if (tokensEsperados.contains("->") || tokensEsperados.contains("<IDENTIFICADOR>")){
            errosSintaticos.append("Erro sintático: Formato da Atribuição está incorreto.").append("\n\n");
        }
    }
}

void entrada(AnalisadorSemantico analisadorSemantico): {} {
    try {
        <GET> {analisadorSemantico.reconheceGet();} <PARENESQ> listaIdentificadores(analisadorSemantico) <PARENDIR> <PONTO>
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Entrada: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<GET> <PARENESQ> listaIdentificadores() <PARENDIR> <PONTO>' \n");

        if (tokensEsperados.contains("(") || tokensEsperados.contains(")")){
            errosSintaticos.append("Erro sintático: identificadores devem estar entre '(' e ')'").append("\n\n");
        } else if (tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sintático: Entrada deve acabar com '.'").append("\n\n");
        } else if (tokensEsperados.contains("get")) {
            errosSintaticos.append("Erro sintático: Entrada deve começar com a palavra reservada 'get'").append("\n\n");
        }
    }
}

void saida(AnalisadorSemantico analisadorSemantico): {} {
    try {
        <PUT> <PARENESQ> identconst(analisadorSemantico) <PARENDIR> <PONTO>
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Saída: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<PUT> <PARENESQ> identconst() <PARENDIR> <PONTO>' \n");

        if (tokensEsperados.contains("(") || tokensEsperados.contains(")")){
            errosSintaticos.append("Erro sintático: identificador de constantes ou variáveis deve estar entre '(' e ')'").append("\n\n");
        } else if (tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sintático: Saída deve acabar com '.'").append("\n\n");
        } else if (tokensEsperados.contains("put")) {
            errosSintaticos.append("Erro sintático: Saída deve começar com a palavra reservada 'put'").append("\n\n");
        }
    }
}

void listaComandos(AnalisadorSemantico analisadorSemantico): {} {
    try {
        comando(analisadorSemantico) restoListaComandos(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("listaComandos: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'comando() restoListaComandos()' \n");
    }
}

void restoListaComandos(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [comando(analisadorSemantico) restoListaComandos(analisadorSemantico)]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("restoListaComandos: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[comando() restoListaComandos()]' \n");
    }
}

void comando(AnalisadorSemantico analisadorSemantico): {} {
    try {
        atribuicao(analisadorSemantico) | entrada(analisadorSemantico) | saida(analisadorSemantico) | selecao(analisadorSemantico) | repeticao(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("comando: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'atribuicao() | entrada() | saida() | selecao() | repeticao()' \n");

        if (tokensEsperados.contains("const") || tokensEsperados.contains("get") || tokensEsperados.contains("put") || tokensEsperados.contains("while") || tokensEsperados.contains("if") || tokensEsperados.contains("var")) {
            errosSintaticos.append("Erro sintático: Comando não definido, utilize um dos comandos: const, get, put, while, if ou var").append("\n\n");
        }
    }
}

void tipos_const(AnalisadorSemantico analisadorSemantico): {} {
    try {
       <INT> {analisadorSemantico.reconheceInt();} | <REAL> {analisadorSemantico.reconheceReal();} | <CHAR> {analisadorSemantico.reconheceChar();}
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("tipos_const: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<INT> | <REAL> | <CHAR>' \n");

        if (tokensEsperados.contains("int") || tokensEsperados.contains("real") || tokensEsperados.contains("char")) {
            errosSintaticos.append("Erro sintático: Constantes só podem ser do tipo INT, REAL ou CHAR").append("\n\n");
        }
    }
}

void tipos_var(AnalisadorSemantico analisadorSemantico): {Token token;} {
    try {
       <INT> {analisadorSemantico.reconheceInt();} | <REAL> {analisadorSemantico.reconheceReal();} | <CHAR> {analisadorSemantico.reconheceChar();}| token = <BOOL> {analisadorSemantico.reconheceBool(token.beginLine, token.beginColumn);}
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("tipos_var: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<INT> | <REAL> | <CHAR> | <BOOL>' \n");

        if (tokensEsperados.contains("int") || tokensEsperados.contains("real") || tokensEsperados.contains("char") || tokensEsperados.contains("bool")) {
            errosSintaticos.append("Erro sintático: Variáveis só podem ser do tipo INT, REAL, CHAR ou BOOL").append("\n\n");
        }
    }
}

void valor(AnalisadorSemantico analisadorSemantico): {Token valor1, valor2, valor3;} {
    try {
       valor1 = <CONSTANTE_NUMERICA_INTEIRA> {analisadorSemantico.reconhceValorDeclaracaoConst(valor1);} | valor2 = <CONSTANTE_NUMERICA_REAL> {analisadorSemantico.reconhceValorDeclaracaoConst(valor2);}| valor3 = <CONSTANTE_LITERAL> {analisadorSemantico.reconhceValorDeclaracaoConst(valor3);}
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("valor: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<CONSTANTE_NUMERICA_INTEIRA> | <CONSTANTE_NUMERICA_REAL> | <CONSTANTE_LITERAL>' \n");

        if (tokensEsperados.contains("<CONSTANTE_NUMERICA_REAL>") || tokensEsperados.contains("<CONSTANTE_NUMERICA_INTEIRA>") || tokensEsperados.contains("<CONSTANTE_LITERAL>")) {
            errosSintaticos.append("Erro sintático: Valor deve ser Constante Numérica Inteira OU Constante Numérica Real OU Constante Literal").append("\n\n");
        }
    }
}

void expressao(AnalisadorSemantico analisadorSemantico): {} {
    try {
       expressaoAritmeticaLogica(analisadorSemantico) expressaoLinha(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Expressão: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'expressaoAritmeticaLogica(analisadorSemantico) expressaoLinha()' \n");
    }
}

void expressaoLinha(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [<IGUAL> expressaoAritmeticaLogica(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoRelacionalIgual();} |
        <DIFERENTE> expressaoAritmeticaLogica(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoRelacionalDiferente();} |
        <MENOR> expressaoAritmeticaLogica(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoRelacionalMenor();} |
        <MAIOR> expressaoAritmeticaLogica(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoRelacionalMaior();} |
        <MENORIGUAL> expressaoAritmeticaLogica(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoRelacionalMenorIgual();} |
        <MAIORIGUAL> expressaoAritmeticaLogica(analisadorSemantico){analisadorSemantico.reconhecerOperacaoRelacionalMaiorIgual();} ]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("expressaoLinha: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        /*errosSintaticos.append("Formato esperado: '[<IGUAL> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("<DIFERENTE> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MENOR> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MAIOR> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MENORIGUAL> expressaoAritmeticaLogica(analisadorSemantico) | \n");
        errosSintaticos.append("'<MAIORIGUAL> expressaoAritmeticaLogica(analisadorSemantico)]' \n");*/

        if (tokensEsperados.contains("=") || tokensEsperados.contains("<>") || tokensEsperados.contains("<") || tokensEsperados.contains(">") || tokensEsperados.contains(">=") || tokensEsperados.contains("<=")) {
            errosSintaticos.append("Erro sintático: As expressões devem conter um dos seguintes símbolos: '=', '<>', '<', '>', '<=', '>=' ").append("\n\n");
        }
    }
}

void expressaoAritmeticaLogica(AnalisadorSemantico analisadorSemantico): {} {
    try {
        termo2(analisadorSemantico) menorPrioridade(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("expressaoAritmeticaLogica: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'termo2(analisadorSemantico) menorPrioridade(analisadorSemantico)' \n");
    }
}

void menorPrioridade(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [<MAIS> termo2(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoAritmeticaAdicao();} menorPrioridade(analisadorSemantico) |
        <MENOS> termo2(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoAritmeticaSubtracao();} menorPrioridade(analisadorSemantico) |
        <OU> termo2(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoLogicaOu();} menorPrioridade(analisadorSemantico)]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("menorPrioridade: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        /*errosSintaticos.append("Formato esperado: '[<MAIS> termo2(analisadorSemantico) menorPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<MENOS> termo2(analisadorSemantico) menorPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<OU> termo2(analisadorSemantico) menorPrioridade(analisadorSemantico)]' \n");*/

        if (tokensEsperados.contains("+") || tokensEsperados.contains("-") || tokensEsperados.contains("|")) {
            errosSintaticos.append("Erro sintático: Expressão deve conter um dos seguintes símbolos: '+', '-', '|' ").append("\n\n");
        }
    }
}

void termo2(AnalisadorSemantico analisadorSemantico): {} {
    try {
        termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("TERMO2: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico)' \n");
    }
}

void mediaPrioridade(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [<MULTIPLICACAO> termo1(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoAritmeticaMultiplicacao();} mediaPrioridade(analisadorSemantico) |
        <DIVISAO> termo1(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoAritmeticaDivisaoReal();} mediaPrioridade(analisadorSemantico) |
        <DIVISAOINTEIRA> termo1(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoAritmeticaDivisaoInteira();} mediaPrioridade(analisadorSemantico) |
        <RESTODIVISAOINTEIRA> termo1(analisadorSemantico) {analisadorSemantico.reconhecerOperacaoAritmeticaRestoDivisaoInteira();} mediaPrioridade(analisadorSemantico) |
        <E> termo1(analisadorSemantico) {analisadorSemantico.reconheceOperacaoLogicaE();} mediaPrioridade(analisadorSemantico)]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("MediaPrioridade: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        /*errosSintaticos.append("Formato esperado: '[<MULTIPLICACAO> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<DIVISAO> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<DIVISAOINTEIRA> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<RESTODIVISAOINTEIRA> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico) | \n");
        errosSintaticos.append("<E> termo1(analisadorSemantico) mediaPrioridade(analisadorSemantico)]'");*/

        if (tokensEsperados.contains("*") || tokensEsperados.contains("/") || tokensEsperados.contains("%") || tokensEsperados.contains("%%") || tokensEsperados.contains("&")) {
            errosSintaticos.append("Erro sintático: Expressão deve conter um dos seguintes símbolos: '*', '/', '%', '%%', '&' ").append("\n\n");
        }
    }
}

void termo1(AnalisadorSemantico analisadorSemantico): {} {
    try {
      elemento(analisadorSemantico) maiorPrioridade(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("TERMO1: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'elemento() maiorPrioridade()' \n");
    }
}

void maiorPrioridade(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [<POTENCIA> elemento(analisadorSemantico){analisadorSemantico.reconhecerOperacaoAritmeticaPotenciacao();} maiorPrioridade(analisadorSemantico)]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("maiorPrioridade: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        // errosSintaticos.append("Formato esperado: '[<POTENCIA> elemento() maiorPrioridade()]' \n");

        if (tokensEsperados.contains("**")) {
            errosSintaticos.append("Erro sintático: Expressão deve conter o símbolo: '**' ").append("\n\n");
        }
    }
}

void elemento(AnalisadorSemantico analisadorSemantico): {Token identificador, constInt, constFloat, constLit;} {
    try {
        identificador = <IDENTIFICADOR> {analisadorSemantico.reconhecerIdentificadorSaidaOuExpressao(identificador);} |
        constInt = <CONSTANTE_NUMERICA_INTEIRA> {analisadorSemantico.reconhecerConstanteInteira(constInt);} |
        constFloat = <CONSTANTE_NUMERICA_REAL> {analisadorSemantico.reconhecerConstanteReal(constFloat);} |
        constLit = <CONSTANTE_LITERAL> {analisadorSemantico.reconhecerConstanteLiteral(constLit);} |
        <TRUE> {analisadorSemantico.reconhecerConstanteLogicaVerdadeiro();} |
        <FALSE> {analisadorSemantico.reconhecerConstanteLogicaFalso();}|
        <PARENESQ> expressao(analisadorSemantico)
        <PARENDIR> | <NAO> <PARENESQ> expressao(analisadorSemantico) <PARENDIR> {analisadorSemantico.reconheceOperacaoLogicaNao();}
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Elemento: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<IDENTIFICADOR> | <CONSTANTE_NUMERICA_INTEIRA> | <CONSTANTE_NUMERICA_REAL> | <CONSTANTE_LITERAL> | <TRUE> | <FALSE> | <PARENESQ> expressao(analisadorSemantico) <PARENDIR> | <NAO> <PARENESQ> expressao(analisadorSemantico) <PARENDIR>' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>") || tokensEsperados.contains("<CONSTANTE_NUMERICA_INTEIRA>") || tokensEsperados.contains("<CONSTANTE_NUMERICA_REAL") || tokensEsperados.contains("<CONSTANTE_LITERAL") || tokensEsperados.contains("true") || tokensEsperados.contains("false")) {
            errosSintaticos.append("Erro sintático: Elemento deve ser um: Identificador OU Constante Numérica Inteira OU Constante Numérica Real OU Constante Literal OU 'true' OU 'false'").append("\n\n");
        } else if (tokensEsperados.contains("(") || tokensEsperados.contains(")")) {
            errosSintaticos.append("Erro sintático: Elemento deve estar entre '(' e ')'").append("\n\n");
        } else if (tokensEsperados.contains("!") || tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sintático: Elemento deve estar entre '!(' e ')'").append("\n\n");
        }
    }
}

void listaIdentificadores(AnalisadorSemantico analisadorSemantico): {Token identificadorToken;} {
    try {
        identificadorToken = <IDENTIFICADOR> {analisadorSemantico.reconheceIdentificador(identificadorToken);} restoLista(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("ListaIdentificadores: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<IDENTIFICADOR> restoLista()' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>")) {
            errosSintaticos.append("Erro sintático: Comando deve conter pelo menos um identificador").append("\n\n");
        }
    }
}

void restoLista(AnalisadorSemantico analisadorSemantico): {Token identificadorToken;} {
    try {
        [<VIRGULA> identificadorToken=<IDENTIFICADOR> {analisadorSemantico.reconheceIdentificador(identificadorToken);} restoLista(analisadorSemantico)]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("restoLista: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<VIRGULA> <IDENTIFICADOR> restoLista()]' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>")) {
            errosSintaticos.append("Erro sintático: Comando deve conter pelo menos um identificador").append("\n\n");
        } else if (tokensEsperados.contains(",")) {
            errosSintaticos.append("Erro sintático: Identificadores devem ser separados por ','").append("\n\n");
        }
    }
}

void repeticao(AnalisadorSemantico analisadorSemantico): {} {
    try {
        <WHILE> {analisadorSemantico.reconhecerInicioWhile();} expressao(analisadorSemantico) {analisadorSemantico.reconhecerExpressaoComandoRepeticao();} <DO> listaComandos(analisadorSemantico) <END> <PONTO> {analisadorSemantico.reconhecerFimComandoRepeticao();}
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Repetição: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<WHILE> expressao(analisadorSemantico) <DO> listaComandos() <END> <PONTO>' \n");

        if (tokensEsperados.contains("while")){
            errosSintaticos.append("Erro sintático: Repetição deve começar com a palavra reservada 'while'").append("\n\n");
        } else if (tokensEsperados.contains("do")) {
            errosSintaticos.append("Erro sintático: Repetição deve conter a palavra reservada 'do'").append("\n\n");
        } else if (tokensEsperados.contains("end") || tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sintático: Repetição deve acabar com a palavra reservada 'end.'").append("\n\n");
        }
    }
}

void selecao(AnalisadorSemantico analisadorSemantico): {} {
    try {
        <IF> expressao(analisadorSemantico) {analisadorSemantico.reconhecerExpressaoComandoSelecao();} <THEN> listaComandos(analisadorSemantico) senao(analisadorSemantico) <END> <PONTO> {analisadorSemantico.reconhecerFimComandoSelecao();}
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Seleção: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '<IF> expressao(analisadorSemantico) <THEN> listaComandos() senao() <END> <PONTO>' \n");

        if (tokensEsperados.contains("if")){
            errosSintaticos.append("Erro sintático: Seleção deve começar com a palavra reservada 'if'").append("\n\n");
        } else if (tokensEsperados.contains("then")) {
            errosSintaticos.append("Erro sintático: Seleção deve conter a palavra reservada 'then'").append("\n\n");
        } else if (tokensEsperados.contains("end") || tokensEsperados.contains(".")) {
            errosSintaticos.append("Erro sintático: Seleção deve acabar com a palavra reservada 'end.'").append("\n\n");
        }
    }
}

void senao(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [<ELSE> {analisadorSemantico.reconhecerClausulaSenao();} listaComandos(analisadorSemantico)]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("Senão: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<ELSE> listaComandos()]' \n");

        if (tokensEsperados.contains("else")) {
            errosSintaticos.append("Erro sintático: Seleção deve contér a palavra reservada 'else'").append("\n\n");
        }
    }
}

void identconst(AnalisadorSemantico analisadorSemantico): {} {
    try {
        identconstAux(analisadorSemantico) {analisadorSemantico.reconheceMensagemSaidaDados();} restoIdentconst(analisadorSemantico)
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("identConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'identconstAux() restoIdentconst()' \n");
    }
}

void restoIdentconst(AnalisadorSemantico analisadorSemantico): {} {
    try {
        [<VIRGULA> identconst(analisadorSemantico)]
    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("restoIdentConst: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: '[<VIRGULA> identconstAux() restoIdentconst()]' \n");

        if (tokensEsperados.contains(",")) {
            errosSintaticos.append("Erro sintático: Comando deve conter ','").append("\n\n");
        }
    }
}

void identconstAux(AnalisadorSemantico analisadorSemantico): {Token identificador, constInt, constFloat, constLit;} {
    try {
        identificador = <IDENTIFICADOR> {analisadorSemantico.reconhecerIdentificadorSaidaOuExpressao(identificador);} |
        constInt = <CONSTANTE_NUMERICA_INTEIRA> {analisadorSemantico.reconhecerConstanteInteira(constInt);} |
        constFloat = <CONSTANTE_NUMERICA_REAL> {analisadorSemantico.reconhecerConstanteReal(constFloat);} |
        constLit = <CONSTANTE_LITERAL> {analisadorSemantico.reconhecerConstanteLiteral(constLit);} |
        <TRUE> {analisadorSemantico.reconhecerConstanteLogicaVerdadeiro();} |
        <FALSE> {analisadorSemantico.reconhecerConstanteLogicaFalso();}

    } catch (ParseException e) {
        countParseError++;
        String tokensEsperados = criaListaEsperados(e.expectedTokenSequences);
        System.out.println("identConstAux: " + tokensEsperados);

        errosSintaticos.append("Linha ").append(e.currentToken.next.beginLine).append(", coluna ").append(e.currentToken.next.beginColumn).append("\n");
        errosSintaticos.append("Encontrou: ").append(e.currentToken.next.image).append(" Esperava: ").append(tokensEsperados).append("\n");
        //errosSintaticos.append("Formato esperado: 'valor() | <IDENTIFICADOR>' \n");

        if (tokensEsperados.contains("<IDENTIFICADOR>")) {
            errosSintaticos.append("Erro sintático: Esperava Identificador ou constante").append("\n\n");
        }
    }
}