options {
    IGNORE_CASE = true;
    STATIC = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Language2025x2)
package org.example.JavaCC;

import java.util.Set;
import java.util.TreeSet;
import java.util.HashSet;

public class Language2025x2 {

    public StringBuilder errosSintaticos = new StringBuilder();
    private Token ultimoErroReportado = null;
    private boolean debug_recovery = true; // Mude para false para desativar as mensagens de debug

    public static class RecoverySet extends HashSet<Integer> {
        public RecoverySet(int... tokens) {
            for (int token : tokens) {
                this.add(token);
            }
        }
    }

    static final RecoverySet declaracaoRecSet = new RecoverySet(SEMICOLON, START);
    static final RecoverySet comandoRecSet = new RecoverySet(SEMICOLON, END, SET, READ, SHOW, IF, LOOP);

    private String criaListaEsperados(ParseException e) {
        Set<String> tokensEsperados = new TreeSet<>();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                String tokenImage = e.tokenImage[e.expectedTokenSequences[i][j]];
                String tokenLimpo = tokenImage.replaceAll("^<|>$", "").replaceAll("\"", "");
                tokensEsperados.add(tokenLimpo.toLowerCase());
            }
        }
        return String.join(", ", tokensEsperados);
    }

    void reportaErro(ParseException e, String met) {
        Token t = e.currentToken.next;
        if (t == ultimoErroReportado) {
            return;
        }
        ultimoErroReportado = t;

        String encontrado = t.image;
        String esperados = criaListaEsperados(e);
        String erroMsg = String.format(
            "Erro Sintático na linha %d, coluna %d (na regra '%s'): Encontrado '%s', mas esperava um de: [%s]\n",
            t.beginLine, t.beginColumn, met, encontrado, esperados);
        errosSintaticos.append(erroMsg);
        System.err.print(erroMsg);
    }


    void consumeUntil(RecoverySet g, ParseException e, String met) {
        reportaErro(e, met); // Reporta o erro original

        if (debug_recovery) {
            System.out.println();
            System.out.println("*** Recuperando do erro em '" + met + "' ***");
            System.out.println("    Procurando por um token no conjunto: " + g);
        }

        Token tok = getToken(1); // Pega o token atual sem consumir

        while (tok.kind != EOF) {
            if (g.contains(tok.kind)) { // Achou um token de sincronização
                if (debug_recovery) {
                    System.out.println("    Encontrado token de sincronização: " + tokenImage[tok.kind]);
                    System.out.println("*** Fim da Recuperação ***");
                    System.out.println();
                }
                break; // Sai do laço, a recuperação terminou
            }
            if (debug_recovery) {
                System.out.println("    Ignorando token: " + tokenImage[tok.kind]);
            }
            getNextToken();      // Consome o token atual
            tok = getToken(1);   // Pega o próximo
        }
    }
}
PARSER_END(Language2025x2)

SPECIAL_TOKEN :{
    <SINGLE_LINE_COMMENT: "#" (~["\n","\r"] )*>
    | < BLOCK_COMMENT : "/*" ( ~["*"] | "*" ~["/"] )* "*/" >
}

SKIP: {
      " "
    | "\n"
    | "\r"
    | "\t"
}

TOKEN : {
    <BEGIN: "begin">
    | <DEFINE: "define">
    | <START: "start">
    | <END: "end">
    | <SET: "set">
    | <TYPE_NUM: "num">
    | <TYPE_REAL: "real">
    | <TYPE_TEXT: "text">
    | <TYPE_FLAG: "flag">
    | <READ: "read">
    | <SHOW: "show">
    | <IF: "if">
    | <THEN: "then">
    | <ELSE: "else">
    | <TRUE: "true">
    | <FALSE: "false">
    | <LOOP: "loop">
    | <WHILE: "while">

    | <TEXT : ( "\"" ( "\\" ~[] | ~["\"", "\\", "\n", "\r"] )* "\"" ) | ( "\'" ( "\\" ~[] | ~["\'", "\\", "\n", "\r"] )* "\'" )>
    | <REAL: ( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )? ( ["0"-"9"] )? "." (( ["0"-"9"] ) | ( ["0"-"9"] ) ( ["0"-"9"] ) )>
    | <NUM: ( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )?>

    | <EQUAL: "==">
    | <NOT_EQUAL: "!=">
    | <SEMICOLON: ";">
    | <ASSIGN: "=">
    | <COLON: ":">
    | <COMMA: ",">
    | <DOT: ".">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <PLUS: "+">
    | <MINUS: "-">
    | <SHIFT_RIGHT_ASSIGN: ">>=">
    | <STAR: "*">
    | <SLASH: "/">
    | <PERCENT: "%">
    | <POWER: "**">
    | <DOUBLE_PERCENT: "%%">
    | <SHIFT_LEFT: "<<">
    | <SHIFT_RIGHT: ">>">
    | <SHIFT_LEFT_ASSIGN: "<<=">
    | <EXCLAMATION: "!">
    | <PIPE: "|">
    | <AMPERSAND: "&">

    | <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] ( ( ["0"-"9"] )? ["a"-"z", "A"-"Z", "_"] )* >

    | <ERROR_NUMBER_TOO_MANY_DIGITS: ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+>
    | <ERROR_IDENTIFIER_START_WITH_NUM: ["0"-"9"]( ["a"-"z", "A"-"Z", "0"-"9", "_"] )* >
    | <ERROR_IDENTIFIER_WITH_MANY_NUMS: ( ["a"-"z", "A"-"Z", "0"-"9", "_"] )*  ( ["0"-"9"] )+ (["a"-"z", "A"-"Z", "_"] )+ >
    | <ERROR_IDENTIFIER_ENDS_WITH_NUM: ( ["a"-"z", "A"-"Z", "0"-"9", "_"] )* ( ["0"-"9"] ) >
    | <ERROR_UNTERMINATED_STRING: (( "\"" ( "\\" ~[] | ~["\"", "\\", "\n", "\r"] )* ) | ( "\'" ( "\\" ~[] | ~["\'", "\\", "\n", "\r"] )* )) >
    | <ERROR_UNTERMINATED_COMMENT: "/*" (~["*"] | "*" ~["/"])* >

    | <ERROR_REAL_TOO_MANY_DIGITS1:( ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ "." ( ["0"-"9"] ) ( ["0"-"9"] )?)>
    | <ERROR_REAL_TOO_MANY_DIGITS2:( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )? ( ["0"-"9"] )? "."  ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+>
    | <ERROR_REAL_TOO_MANY_DIGITS3:( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ "." ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ >
    | <ERROR_INVALID_REAL:( ( ["0"-"9"] ( ["a"-"z", "A"-"Z", "_"] )* )+ "." ( ["a"-"z", "A"-"Z", "0"-"9", "_", "."] )*)>

    | <ERROR_INVALID_SYMBOL: ~[]>
}

void programa():{}
{
    <BEGIN> [ <IDENTIFIER> ]
    [ declaracao() ]
    <START>
    listaDeComandos()
    <END> <DOT>

}

// DECLARACAO DE VARIAVEIS
void declaracao():{}
{
    try{
        <DEFINE> listaDeclaracao()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");

    }
}

void listaDeclaracao():{}
{

   (variosIdentificadores() <COLON> tipos() variosTipos() <SEMICOLON>)+

}

void variosIdentificadores():{}
{
    try{
        <IDENTIFIER> listaIdentificadores()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "lista de Identificadores");

    }
}

void listaIdentificadores():{}
{
      (<COMMA> <IDENTIFIER>)*
}

void tipos():{}
{
    <TYPE_NUM> | <TYPE_REAL> | <TYPE_TEXT> | <TYPE_FLAG>
}

void constants():{}
{
    <NUM> | <REAL> | <TEXT> | <TRUE> | <FALSE>
}

void constantsDeclare():{}
{
    try{
        constants() constantsList()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}

void constantsList():{}
{
    try{
        [ <COMMA> constantsDeclare() ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}

void variosTipos():{}
{
    try{
        [ <ASSIGN> constants() | <LBRACKET> <NUM> <RBRACKET> vectorDeclare() ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }

}

void vectorDeclare():{}
{
    try{
        [ <ASSIGN> <LBRACE> constantsDeclare() <RBRACE> ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}
//Comandos

void listaDeComandos() :{}
{
    try{
        comando()
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void comando():{}
{
    try{
      ( atribuicao() | entrada() | saida() | selecao() | repeticao() ) [ listaDeComandos() ]

    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void atribuicao():{}{
        <SET> <IDENTIFIER> vetor() <ASSIGN> expressao() <SEMICOLON>

}

void entrada():{}
{

        <READ> <LPAREN> <IDENTIFIER> vetor() <RPAREN> <SEMICOLON>

}

void saida():{}
{
        <SHOW> <LPAREN> idOuConst() <RPAREN> <SEMICOLON>

}

void idOuConst():{}
{
        <IDENTIFIER> vetor() listaIdOuConst() | constants() listaIdOuConst()
}

void listaIdOuConst():{}
{
        [ <COMMA> ( <IDENTIFIER>vetor() listaIdOuConst() | constants() listaIdOuConst() ) ]
}

void vetor():{}
{
       [ <LBRACKET> expressao()<RBRACKET> ]

}

void expressao(): {}{
            expAritOuLogi() expressao1()

}

void expressao1(): {}
{
           [ ( <EQUAL> | <NOT_EQUAL> | <SHIFT_LEFT> | <SHIFT_RIGHT> | <SHIFT_LEFT_ASSIGN> | <SHIFT_RIGHT_ASSIGN> ) expAritOuLogi() ]

}

void expAritOuLogi(): {}
{
            termo2() menorPrioridade()
}

void menorPrioridade(): {}
{
        [ ( <PLUS> | <MINUS> | <PIPE> ) termo2() menorPrioridade() ]
}

void termo2(): {}
{
        termo1() mediaPrioridade()
}

void mediaPrioridade(): {}
{
        [ ( <STAR> | <SLASH> | <PERCENT> | <DOUBLE_PERCENT> | <AMPERSAND> ) termo1() mediaPrioridade() ]
}

void termo1(): {}
{
        elemento() maiorPrioridade()

}

void maiorPrioridade(): {}{
        [ <POWER> elemento() maiorPrioridade() ]

}

void elemento(): {}
{
        (<IDENTIFIER> | constants() | [ <EXCLAMATION> ] <LPAREN> expressao() <RPAREN> )

}

void repeticao(): {}
{
    try{
        <LOOP> <WHILE> expressao()
        listaDeComandos()
        <END> <SEMICOLON>
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void selecao(): {}
{
    try{
        <IF> expressao() <THEN>
        listaDeComandos()
        ifelse()
        <END> <SEMICOLON>
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void ifelse(): {} {
    try{
        [ <ELSE> listaDeComandos() ]
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}