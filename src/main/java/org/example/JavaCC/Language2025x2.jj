options {
    IGNORE_CASE = true;
    STATIC = false;
    DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Language2025x2)
package org.example.JavaCC;

import org.example.Actions.AnalisadorSemantico;
import java.util.Set;
import java.util.TreeSet;
import java.util.HashSet;

public class Language2025x2 {
    public AnalisadorSemantico semantico = new AnalisadorSemantico();
    public StringBuilder errosSintaticos = new StringBuilder();
    private Token ultimoErroReportado = null;
    private boolean debug_recovery = true; // Mude para false para desativar as mensagens de debug

    public static class RecoverySet extends HashSet<Integer> {
        public RecoverySet(int... tokens) {
            for (int token : tokens) {
                this.add(token);
            }
        }
    }
    static final RecoverySet programaRecSet = new RecoverySet(START, END, DOT, EOF); // verificar
    static final RecoverySet declaracaoRecSet = new RecoverySet(SEMICOLON, START);
    static final RecoverySet comandoRecSet = new RecoverySet(SEMICOLON, END, SET, READ, SHOW, IF, LOOP);

    private String criaListaEsperados(ParseException e) {
        Set<String> tokensEsperados = new TreeSet<>();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                String tokenImage = e.tokenImage[e.expectedTokenSequences[i][j]];
                String tokenLimpo = tokenImage.replaceAll("^<|>$", "").replaceAll("\"", "");
                tokensEsperados.add("@"+tokenLimpo.toLowerCase());
            }
        }
        return String.join(", ", tokensEsperados);
    }

    void reportaErroSintatico(ParseException e, String met) {
        Token t = e.currentToken.next;
        if (t == ultimoErroReportado) {
            return;
        }
        ultimoErroReportado = t;

        String encontrado = t.image;
        String esperados = criaListaEsperados(e);
        String erroMsg = String.format(
            "<div class='log-entry'><span class='line-info'>Erro Sintático na linha %d, coluna %d:</span><br> Encontrado <span class='found'>@%s</span> mas esperava <span class='expected'>@%s</span></div>\n",
            t.beginLine, t.beginColumn, encontrado.equals("@") || encontrado.equals("@ ") || encontrado.equals(" ") || encontrado.isEmpty() ? "espaco" : encontrado, esperados);
        errosSintaticos.append(erroMsg);
        //System.err.print(erroMsg);
    }


    void consumeUntil(RecoverySet g, ParseException e, String met) {
        reportaErroSintatico(e, met); // Reporta o erro original

        if (debug_recovery) {
            System.out.println();
            System.out.println("*** Recuperando do erro em '" + met + "' ***");
            System.out.println("    Procurando por um token no conjunto: " + g);
        }

        Token tok = getToken(1); // Pega o token atual sem consumir

        while (tok.kind != EOF) {
            if (g.contains(tok.kind)) { // Achou um token de sincronização
                if (debug_recovery) {
                    System.out.println("    Encontrado token de sincronização: " + tokenImage[tok.kind]);
                    System.out.println("*** Fim da Recuperação ***");
                    System.out.println();
                }
                break; // Sai do laço, a recuperação terminou
            }
            if (debug_recovery) {
                System.out.println("    Ignorando token: " + tokenImage[tok.kind]);
            }
            getNextToken();      // Consome o token atual
            tok = getToken(1);   // Pega o próximo
        }
    }
}
PARSER_END(Language2025x2)

SPECIAL_TOKEN :{
    <SINGLE_LINE_COMMENT: "#" (~["\n","\r"] )*>
    | < BLOCK_COMMENT : "/*" ( ~["*"] | "*" ~["/"] )* "*/" >
}

SKIP: {
      " "
    | "\n"
    | "\r"
    | "\t"
}

TOKEN : {
    <BEGIN: "begin">
    | <DEFINE: "define">
    | <START: "start">
    | <END: "end">
    | <SET: "set">
    | <TYPE_NUM: "num">
    | <TYPE_REAL: "real">
    | <TYPE_TEXT: "text">
    | <TYPE_FLAG: "flag">
    | <READ: "read">
    | <SHOW: "show">
    | <IF: "if">
    | <THEN: "then">
    | <ELSE: "else">
    | <TRUE: "true">
    | <FALSE: "false">
    | <LOOP: "loop">
    | <WHILE: "while">

    | <TEXT : ( "\"" ( "\\" ~[] | ~["\"", "\\", "\n", "\r"] )* "\"" ) | ( "\'" ( "\\" ~[] | ~["\'", "\\", "\n", "\r"] )* "\'" )>
    | <REAL: ( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )? ( ["0"-"9"] )? "." (( ["0"-"9"] ) | ( ["0"-"9"] ) ( ["0"-"9"] ) )>
    | <NUM: ( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )?>

    | <EQUAL: "==">
    | <NOT_EQUAL: "!=">
    | <SEMICOLON: ";">
    | <ASSIGN: "=">
    | <COLON: ":">
    | <COMMA: ",">
    | <DOT: ".">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <PLUS: "+">
    | <MINUS: "-">
    | <SHIFT_RIGHT_ASSIGN: ">>=">
    | <STAR: "*">
    | <SLASH: "/">
    | <PERCENT: "%">
    | <POWER: "**">
    | <DOUBLE_PERCENT: "%%">
    | <SHIFT_LEFT: "<<">
    | <SHIFT_RIGHT: ">>">
    | <SHIFT_LEFT_ASSIGN: "<<=">
    | <EXCLAMATION: "!">
    | <PIPE: "|">
    | <AMPERSAND: "&">

    | <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] ( ( ["0"-"9"] )? ["a"-"z", "A"-"Z", "_"] )* >

    | <ERROR_NUMBER_TOO_MANY_DIGITS: ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+>
    | <ERROR_IDENTIFIER_START_WITH_NUM: ["0"-"9"]( ["a"-"z", "A"-"Z", "0"-"9", "_"] )* >
    | <ERROR_IDENTIFIER_WITH_MANY_NUMS: ( ["a"-"z", "A"-"Z", "0"-"9", "_"] )*  ( ["0"-"9"] )+ (["a"-"z", "A"-"Z", "_"] )+ >
    | <ERROR_IDENTIFIER_ENDS_WITH_NUM: ( ["a"-"z", "A"-"Z", "0"-"9", "_"] )* ( ["0"-"9"] ) >
    | <ERROR_UNTERMINATED_STRING: (( "\"" ( "\\" ~[] | ~["\"", "\\", "\n", "\r"] )* ) | ( "\'" ( "\\" ~[] | ~["\'", "\\", "\n", "\r"] )* )) >
    | <ERROR_UNTERMINATED_COMMENT: "/*" (~["*"] | "*" ~["/"])* >

    | <ERROR_REAL_TOO_MANY_DIGITS1:( ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ "." ( ["0"-"9"] ) ( ["0"-"9"] )?)>
    | <ERROR_REAL_TOO_MANY_DIGITS2:( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )? ( ["0"-"9"] )? "."  ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+>
    | <ERROR_REAL_TOO_MANY_DIGITS3:( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ "." ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ >
    | <ERROR_INVALID_REAL:( ( ["0"-"9"] ( ["a"-"z", "A"-"Z", "_"] )* )+ "." ( ["a"-"z", "A"-"Z", "0"-"9", "_", "."] )*)>

    | <ERROR_INVALID_SYMBOL: ~[]>
}

void programa():{Token identificadorToken;}
{
    try{

        <BEGIN> [identificadorToken = <IDENTIFIER>  {semantico.programa1(identificadorToken);}]
        [ declaracao() ]
        <START>
        listaDeComandos() {semantico.programa2();}
        <END> <DOT>

    }catch(ParseException e){
        consumeUntil(programaRecSet, e, "programa"); //criar recovery set
    }
}

// DECLARACAO DE VARIAVEIS
void declaracao():{}
{
    try{
        <DEFINE> {semantico.declaracao0();} listaDeclaracao()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");

    }
}

void listaDeclaracao():{}
{

   (variosIdentificadores() <COLON> tipos() variosTipos() <SEMICOLON> {semantico.declaracao6();}/*COLOCA D6 AQUI WEEE WOO WEE WOO TODO: SHREK GIGANTE*/)+
   /*⢀⡴⠑⡄⠀⠀⠀⠀⠀⠀⠀⣀⣀⣤⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
   ⠸⡇⠀⠿⡀⠀⠀⠀⣀⡴⢿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠑⢄⣠⠾⠁⣀⣄⡈⠙⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⢀⡀⠁⠀⠀⠈⠙⠛⠂⠈⣿⣿⣿⣿⣿⠿⡿⢿⣆⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⢀⡾⣁⣀⠀⠴⠂⠙⣗⡀⠀⢻⣿⣿⠭⢤⣴⣦⣤⣹⠀⠀⠀⢀⢴⣶⣆
   ⠀⠀⢀⣾⣿⣿⣿⣷⣮⣽⣾⣿⣥⣴⣿⣿⡿⢂⠔⢚⡿⢿⣿⣦⣴⣾⠁⠸⣼⡿
   ⠀⢀⡞⠁⠙⠻⠿⠟⠉⠀⠛⢹⣿⣿⣿⣿⣿⣌⢤⣼⣿⣾⣿⡟⠉⠀⠀⠀⠀⠀
   ⠀⣾⣷⣶⠇⠀⠀⣤⣄⣀⡀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
   ⠀⠉⠈⠉⠀⠀⢦⡈⢻⣿⣿⣿⣶⣶⣶⣶⣤⣽⡹⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠉⠲⣽⡻⢿⣿⣿⣿⣿⣿⣿⣷⣜⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣷⣶⣮⣭⣽⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀ 
   ⠀⠀⠀⠀⠀⠀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⠿⠿⠿⠛⠉*/

}

void variosIdentificadores(): {Token identificadorToken;}
{
    try{
        identificadorToken = <IDENTIFIER> {semantico.declaracao1(identificadorToken);} listaIdentificadores()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "lista de Identificadores");

    }
}

void listaIdentificadores():{Token identificadorToken;}
{
      (<COMMA> identificadorToken = <IDENTIFIER> {semantico.declaracao1(identificadorToken);})*
}

void tipos():{Token tipoToken;}
{
   tipoToken = <TYPE_NUM> {semantico.tipo(tipoToken);}| tipoToken = <TYPE_REAL> {semantico.tipo(tipoToken);}| tipoToken = <TYPE_TEXT> {semantico.tipo(tipoToken);}| tipoToken = <TYPE_FLAG> {semantico.tipo(tipoToken);}
}

void constants():{}
{
    <NUM> | <REAL> | <TEXT> | <TRUE> | <FALSE>
}

void constantsDeclare():{}
{
    try{
        constants() constantsList()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}

void constantsList():{}
{
    try{
        [ <COMMA> constantsDeclare() ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}

void variosTipos():{Token valorVetorToken;}
{
    try{
        [ <ASSIGN> constants() {semantico.escalar2();} | <LBRACKET> valorVetorToken = <NUM> {semantico.vetor1(valorVetorToken);} <RBRACKET> vectorDeclare() {semantico.vetor2();} ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }

}

void vectorDeclare():{}
{
    try{
        [ <ASSIGN> <LBRACE> constantsDeclare() <RBRACE> ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}
//Comandos

void listaDeComandos() :{}
{
    try{
        comando()
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void comando():{}
{
    try{
      ( atribuicao() | entrada() | saida() | selecao() | repeticao() ) [ listaDeComandos() ]

    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void atribuicao():{}{
        <SET> <IDENTIFIER> vetor() <ASSIGN> expressao() <SEMICOLON>

}

void entrada():{}
{

        <READ> <LPAREN> <IDENTIFIER> vetor() <RPAREN> <SEMICOLON>

}

void saida():{}
{
        <SHOW> <LPAREN> idOuConst() <RPAREN> <SEMICOLON>

}

void idOuConst():{}
{
        <IDENTIFIER> vetor() listaIdOuConst() | constants() listaIdOuConst()
}

void listaIdOuConst():{}
{
        [ <COMMA> ( <IDENTIFIER>vetor() listaIdOuConst() | constants() listaIdOuConst() ) ]
}

void vetor():{}
{
       [ <LBRACKET> expressao()<RBRACKET> ]

}

void expressao(): {}{
            expAritOuLogi() expressao1()

}

void expressao1(): {}
{
           [ ( <EQUAL> | <NOT_EQUAL> | <SHIFT_LEFT> | <SHIFT_RIGHT> | <SHIFT_LEFT_ASSIGN> | <SHIFT_RIGHT_ASSIGN> ) expAritOuLogi() ]

}

void expAritOuLogi(): {}
{
            termo2() menorPrioridade()
}

void menorPrioridade(): {}
{
        [ ( <PLUS> | <MINUS> | <PIPE> ) termo2() menorPrioridade() ]
}

void termo2(): {}
{
        termo1() mediaPrioridade()
}

void mediaPrioridade(): {}
{
        [ ( <STAR> | <SLASH> | <PERCENT> | <DOUBLE_PERCENT> | <AMPERSAND> ) termo1() mediaPrioridade() ]
}

void termo1(): {}
{
        elemento() maiorPrioridade()

}

void maiorPrioridade(): {}{
        [ <POWER> elemento() maiorPrioridade() ]

}

void elemento(): {}
{
        (<IDENTIFIER> | constants() | [ <EXCLAMATION> ] <LPAREN> expressao() <RPAREN> )

}

void repeticao(): {}
{
    try{
        <LOOP> <WHILE> expressao()
        listaDeComandos()
        <END> <SEMICOLON>
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void selecao(): {}
{
    try{
        <IF> expressao() <THEN>
        listaDeComandos()
        ifelse()
        <END> <SEMICOLON>
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void ifelse(): {} {
    try{
        [ <ELSE> listaDeComandos() ]
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}