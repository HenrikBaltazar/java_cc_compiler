options {
    IGNORE_CASE = true;
    STATIC = false;
    DEBUG_LOOKAHEAD = false;
}

PARSER_BEGIN(Language2025x2)
package org.example.JavaCC;

import org.example.Actions.AnalisadorSemantico;
import java.util.Set;
import java.util.TreeSet;
import java.util.HashSet;

public class Language2025x2 {
    public AnalisadorSemantico semantico = new AnalisadorSemantico();
    public StringBuilder errosSintaticos = new StringBuilder();
    private Token ultimoErroReportado = null;
    private boolean debug_recovery = true; // Mude para false para desativar as mensagens de debug

    public static class RecoverySet extends HashSet<Integer> {
        public RecoverySet(int... tokens) {
            for (int token : tokens) {
                this.add(token);
            }
        }
    }
    static final RecoverySet programaRecSet = new RecoverySet(START, END, DOT, EOF); // verificar
    static final RecoverySet declaracaoRecSet = new RecoverySet(SEMICOLON, START);
    static final RecoverySet comandoRecSet = new RecoverySet(SEMICOLON, END, SET, READ, SHOW, IF, LOOP);

    private String criaListaEsperados(ParseException e) {
        Set<String> tokensEsperados = new TreeSet<>();
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                String tokenImage = e.tokenImage[e.expectedTokenSequences[i][j]];
                String tokenLimpo = tokenImage.replaceAll("^<|>$", "").replaceAll("\"", "");
                tokensEsperados.add("@"+tokenLimpo.toLowerCase());
            }
        }
        return String.join(", ", tokensEsperados);
    }

    void reportaErroSintatico(ParseException e, String met) {
        Token t = e.currentToken.next;
        if (t == ultimoErroReportado) {
            return;
        }
        ultimoErroReportado = t;

        String encontrado = t.image;
        String esperados = criaListaEsperados(e);
        String erroMsg = String.format(
            "<div class='log-entry'><span class='line-info'>Erro Sintático na linha %d, coluna %d:</span><br> Encontrado <span class='found'>@%s</span> mas esperava <span class='expected'>@%s</span></div>\n",
            t.beginLine, t.beginColumn, encontrado.equals("@") || encontrado.equals("@ ") || encontrado.equals(" ") || encontrado.isEmpty() ? "espaco" : encontrado, esperados);
        errosSintaticos.append(erroMsg);
        //System.err.print(erroMsg);
    }


    void consumeUntil(RecoverySet g, ParseException e, String met) {
        reportaErroSintatico(e, met); // Reporta o erro original

        if (debug_recovery) {
            System.out.println();
            System.out.println("*** Recuperando do erro em '" + met + "' ***");
            System.out.println("    Procurando por um token no conjunto: " + g);
        }

        Token tok = getToken(1); // Pega o token atual sem consumir

        while (tok.kind != EOF) {
            if (g.contains(tok.kind)) { // Achou um token de sincronização
                if (debug_recovery) {
                    System.out.println("    Encontrado token de sincronização: " + tokenImage[tok.kind]);
                    System.out.println("*** Fim da Recuperação ***");
                    System.out.println();
                }
                break; // Sai do laço, a recuperação terminou
            }
            if (debug_recovery) {
                System.out.println("    Ignorando token: " + tokenImage[tok.kind]);
            }
            getNextToken();      // Consome o token atual
            tok = getToken(1);   // Pega o próximo
        }
    }
}
PARSER_END(Language2025x2)

SPECIAL_TOKEN :{
    <SINGLE_LINE_COMMENT: "#" (~["\n","\r"] )*>
    | < BLOCK_COMMENT : "/*" ( ~["*"] | "*" ~["/"] )* "*/" >
}

SKIP: {
      " "
    | "\n"
    | "\r"
    | "\t"
}

TOKEN : {
    <BEGIN: "begin">
    | <DEFINE: "define">
    | <START: "start">
    | <END: "end">
    | <SET: "set">
    | <TYPE_NUM: "num">
    | <TYPE_REAL: "real">
    | <TYPE_TEXT: "text">
    | <TYPE_FLAG: "flag">
    | <READ: "read">
    | <SHOW: "show">
    | <IF: "if">
    | <THEN: "then">
    | <ELSE: "else">
    | <TRUE: "true">
    | <FALSE: "false">
    | <LOOP: "loop">
    | <WHILE: "while">

    | <TEXT : ( "\"" ( "\\" ~[] | ~["\"", "\\", "\n", "\r"] )* "\"" ) | ( "\'" ( "\\" ~[] | ~["\'", "\\", "\n", "\r"] )* "\'" )>
    | <REAL: ( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )? ( ["0"-"9"] )? "." (( ["0"-"9"] ) | ( ["0"-"9"] ) ( ["0"-"9"] ) )>
    | <NUM: ( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )?>

    | <EQUAL: "==">
    | <NOT_EQUAL: "!=">
    | <SEMICOLON: ";">
    | <ASSIGN: "=">
    | <COLON: ":">
    | <COMMA: ",">
    | <DOT: ".">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <PLUS: "+">
    | <MINUS: "-">
    | <SHIFT_RIGHT_ASSIGN: ">>=">
    | <STAR: "*">
    | <SLASH: "/">
    | <PERCENT: "%">
    | <POWER: "**">
    | <DOUBLE_PERCENT: "%%">
    | <SHIFT_LEFT: "<<">
    | <SHIFT_RIGHT: ">>">
    | <SHIFT_LEFT_ASSIGN: "<<=">
    | <EXCLAMATION: "!">
    | <PIPE: "|">
    | <AMPERSAND: "&">

    | <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] ( ( ["0"-"9"] )? ["a"-"z", "A"-"Z", "_"] )* >

    | <ERROR_NUMBER_TOO_MANY_DIGITS: ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+>
    | <ERROR_IDENTIFIER_START_WITH_NUM: ["0"-"9"]( ["a"-"z", "A"-"Z", "0"-"9", "_"] )* >
    | <ERROR_IDENTIFIER_WITH_MANY_NUMS: ( ["a"-"z", "A"-"Z", "0"-"9", "_"] )*  ( ["0"-"9"] )+ (["a"-"z", "A"-"Z", "_"] )+ >
    | <ERROR_IDENTIFIER_ENDS_WITH_NUM: ( ["a"-"z", "A"-"Z", "0"-"9", "_"] )* ( ["0"-"9"] ) >
    | <ERROR_UNTERMINATED_STRING: (( "\"" ( "\\" ~[] | ~["\"", "\\", "\n", "\r"] )* ) | ( "\'" ( "\\" ~[] | ~["\'", "\\", "\n", "\r"] )* )) >
    | <ERROR_UNTERMINATED_COMMENT: "/*" (~["*"] | "*" ~["/"])* >

    | <ERROR_REAL_TOO_MANY_DIGITS1:( ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ "." ( ["0"-"9"] ) ( ["0"-"9"] )?)>
    | <ERROR_REAL_TOO_MANY_DIGITS2:( ["0"-"9"] ) ( ["0"-"9"] )? ( ["0"-"9"] )? ( ["0"-"9"] )? "."  ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+>
    | <ERROR_REAL_TOO_MANY_DIGITS3:( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ "." ( ["0"-"9"] ) ( ["0"-"9"] ) ( ["0"-"9"] )+ >
    | <ERROR_INVALID_REAL:( ( ["0"-"9"] ( ["a"-"z", "A"-"Z", "_"] )* )+ "." ( ["a"-"z", "A"-"Z", "0"-"9", "_", "."] )*)>

    | <ERROR_INVALID_SYMBOL: ~[]>
}

void programa():{Token identificadorToken;}
{
    try{

        <BEGIN> [identificadorToken = <IDENTIFIER>  {semantico.programa1(identificadorToken);}]
        [ declaracao() ]
        <START>
        listaDeComandos() {semantico.programa2();}
        <END> <DOT>

    }catch(ParseException e){
        consumeUntil(programaRecSet, e, "programa"); //criar recovery set
    }
}

// DECLARACAO DE VARIAVEIS
void declaracao():{}
{
    try{
        <DEFINE> {semantico.declaracao0();} listaDeclaracao()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");

    }
}

void listaDeclaracao():{}
{

   (variosIdentificadores() <COLON> tipos() variosTipos() <SEMICOLON>{semantico.declaracao6();}/*COLOCA D6 AQUI WEEE WOO WEE WOO TODO: SHREK GIGANTE*/)+
   /*⢀⡴⠑⡄⠀⠀⠀⠀⠀⠀⠀⣀⣀⣤⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
   ⠸⡇⠀⠿⡀⠀⠀⠀⣀⡴⢿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠑⢄⣠⠾⠁⣀⣄⡈⠙⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⢀⡀⠁⠀⠀⠈⠙⠛⠂⠈⣿⣿⣿⣿⣿⠿⡿⢿⣆⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⢀⡾⣁⣀⠀⠴⠂⠙⣗⡀⠀⢻⣿⣿⠭⢤⣴⣦⣤⣹⠀⠀⠀⢀⢴⣶⣆
   ⠀⠀⢀⣾⣿⣿⣿⣷⣮⣽⣾⣿⣥⣴⣿⣿⡿⢂⠔⢚⡿⢿⣿⣦⣴⣾⠁⠸⣼⡿
   ⠀⢀⡞⠁⠙⠻⠿⠟⠉⠀⠛⢹⣿⣿⣿⣿⣿⣌⢤⣼⣿⣾⣿⡟⠉⠀⠀⠀⠀⠀
   ⠀⣾⣷⣶⠇⠀⠀⣤⣄⣀⡀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
   ⠀⠉⠈⠉⠀⠀⢦⡈⢻⣿⣿⣿⣶⣶⣶⣶⣤⣽⡹⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠉⠲⣽⡻⢿⣿⣿⣿⣿⣿⣿⣷⣜⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣷⣶⣮⣭⣽⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⠿⠿⠿⠛⠉*/

}

void variosIdentificadores(): {Token identificadorToken;}
{
    try{
        identificadorToken = <IDENTIFIER> {semantico.declaracao1(identificadorToken);} listaIdentificadores()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "lista de Identificadores");

    }
}

void listaIdentificadores():{Token identificadorToken;}
{
      (<COMMA> identificadorToken = <IDENTIFIER> {semantico.declaracao1(identificadorToken);})*
}

void tipos():{Token tipoToken;}
{
   tipoToken = <TYPE_NUM> {semantico.tipo(tipoToken);}| tipoToken = <TYPE_REAL> {semantico.tipo(tipoToken);}| tipoToken = <TYPE_TEXT> {semantico.tipo(tipoToken);}| tipoToken = <TYPE_FLAG> {semantico.tipo(tipoToken);}
}

void constants():{Token constant;}
{
    constant = <NUM> {semantico.constanteInteira(constant);} | constant = <REAL> {semantico.constanteReal(constant);} | constant = <TEXT> {semantico.constanteLiteral(constant);} | <TRUE> {semantico.constanteVerdadeira();} | <FALSE> {semantico.constanteFalsa();}
}

void constantsDeclare():{}
{
    try{
        constants()  constantsList()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}

void constantsList():{}
{
    try{
        [  <COMMA> constantsDeclare() ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}

void constantsDeclareVetor():{}
{
    try{
        constants()  {semantico.val();} constantsListVetor()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");

    }
}

void constantsListVetor():{}
{
    try{
        [  <COMMA> constantsDeclareVetor() ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");

    }
}

void variosTipos():{Token valorVetorToken;}
{
    try{ //era constants()






       {semantico.escalar2();} iniciaEscalar()  | <LBRACKET> valorVetorToken = <NUM> {semantico.vetor1(valorVetorToken);} <RBRACKET> {semantico.vetor2();} vectorDeclare()
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }

}

void iniciaEscalar():{}
{
try{ //era constants()
      [ <ASSIGN>  constantsDeclare() {semantico.inicializaEscalar();} ]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");

    }
}


void vectorDeclare():{Token brace;}
{
    try{
        [ <ASSIGN> <LBRACE> constantsDeclareVetor() brace=<RBRACE> {semantico.inicializaVet(brace);}]
    }catch(ParseException e){
        consumeUntil(declaracaoRecSet, e, "declaracao");
        
    }
}
//Comandos

void listaDeComandos() :{}
{
    try{
        comando()
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void comando():{}
{
    try{
      ( atribuicao() | entrada() | saida() | selecao() | repeticao() ) [ listaDeComandos() ]

    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void atribuicao():{Token id;}{
        <SET> id=<IDENTIFIER> {semantico.atribuicao1(id);} /*#A1*/ vetor() {semantico.atribuicao2(id);}/*#A2*/ <ASSIGN> expressao() {semantico.atribuicao3();}/*#A3*/ <SEMICOLON>

}

void entrada():{}
{

        <READ> <LPAREN> <IDENTIFIER> vetor() <RPAREN> <SEMICOLON>

}

void saida():{}
{
        <SHOW> <LPAREN> listaDeSaida() <RPAREN> <SEMICOLON>

}

void listaDeSaida():{}
{
        item() listaDeSaida1()
}

void listaDeSaida1():{Token id;}
{
       [ <COMMA> item() listaDeSaida1() ]
}

void item():{Token id;}
{
    id = <IDENTIFIER> {semantico.show2(id);} vetor() {semantico.show3();} | id=<NUM> {semantico.saidaConstInteira(id);} | id=<REAL> {semantico.saidaConstReal(id);} | id=<TEXT> {semantico.saidaConstLiteral(id);}
}

void vetor():{}
{
       [ <LBRACKET> expressao() {semantico.i1();}<RBRACKET> ]

}

void expressao(): {}{
            expAritOuLogi() expressao1()

}

void expressao1(): {}
{
           [  <EQUAL> expAritOuLogi() {semantico.rIgual();} | <NOT_EQUAL> expAritOuLogi() {semantico.rDiferente();} | <SHIFT_LEFT> expAritOuLogi() {semantico.rMenor();} | <SHIFT_RIGHT> expAritOuLogi() {semantico.rMaior();} | <SHIFT_LEFT_ASSIGN> expAritOuLogi() {semantico.rMenorIgual();} | <SHIFT_RIGHT_ASSIGN> expAritOuLogi() {semantico.rMaiorIgual();} ]

}

void expAritOuLogi(): {}
{
            termo2() menorPrioridade()
}

void menorPrioridade(): {}
{
        [ <PLUS> termo2() {semantico.rAdd();} menorPrioridade() | <MINUS> termo2() {semantico.rSub();} menorPrioridade() | <PIPE> termo2() {semantico.rOr();} menorPrioridade() ]
}

void termo2(): {}
{
        termo1() mediaPrioridade()
}

void mediaPrioridade(): {}
{
        [ <STAR> termo1() {semantico.rMul();} mediaPrioridade() | <SLASH> termo1() {semantico.rDiv();} mediaPrioridade() | <PERCENT> termo1() {semantico.rMod();} mediaPrioridade() | <DOUBLE_PERCENT> termo1() {semantico.rRem();} mediaPrioridade() | <AMPERSAND> termo1() {semantico.rAnd();} mediaPrioridade() ]
}

void termo1(): {}
{
        elemento() maiorPrioridade()

}

void maiorPrioridade(): {}{
        [ <POWER> elemento() {semantico.rPow();} maiorPrioridade() ]

}

void elemento(): {Token identToken; Token vetor;}
{
        identToken = <IDENTIFIER> {semantico.expressao1(identToken);} vetor() {semantico.expressao2();} | constants() | <EXCLAMATION> <LPAREN> expressao() <RPAREN> {semantico.rNot();} | <LPAREN> expressao() <RPAREN>

}

void repeticao(): {}
{
    try{
        <LOOP> <WHILE> expressao() {semantico.loop1();}
        listaDeComandos() {semantico.loop2();}
        <END> <SEMICOLON>
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void selecao(): {}
{
    try{
        <IF> expressao() {semantico.selecaoF1();} <THEN>
        listaDeComandos()
        ifelse() {semantico.selecaoF3();}
        <END> <SEMICOLON>
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}

void ifelse(): {} {
    try{
        [ <ELSE> {semantico.selecaoF2();} listaDeComandos() ]
    }catch(ParseException e){
        consumeUntil(comandoRecSet, e, "lista de comandos");

    }
}